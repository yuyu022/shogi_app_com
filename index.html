<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>しゃべる将棋（人 vs CPU）</title>

<style>
:root{
  --cell: 60px;
  --boardW: calc(var(--cell) * 9);
  --handW: 70px;
  --gap: 10px;
}
@media (max-width: 760px){ :root{ --cell: 54px; } }
@media (max-width: 650px){ :root{ --cell: 48px; } }
@media (max-width: 560px){ :root{ --cell: 42px; } }
@media (max-width: 480px){ :root{ --cell: 36px; } }

*{ box-sizing:border-box; }
body{
  font-family:sans-serif;
  margin:0;
  padding:12px;
}

#app{
  width:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
}

#stage{
  width:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
}

/* コントロール全体 */
.controlsWrap{
  width: var(--boardW);
  margin: 10px auto;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.controlsWrap button{
  min-height: 90px;
  font-size: 24px;
  font-weight: 900;
}

/* 上段2つ */
.controlsTop{
  width: var(--boardW);
  display:grid;
  grid-template-columns:repeat(2, 1fr);
  gap:8px;
}

/* 中段3つ */
.controlsBottom{
  width: var(--boardW);
  display:grid;
  grid-template-columns:repeat(3, 1fr);
  gap:8px;
}

/* AIレベル行（5つ） */
#aiLevelRow{
  width: var(--boardW);
  display:grid;
  grid-template-columns:repeat(5, 1fr);
  gap:8px;
}
#aiLevelRow button{
  min-height: 70px;
  font-size: 16px;
  font-weight: 900;
}
.aiSelected{
  outline: 4px solid #ff9800;
  background: #fff3e0;
}

/* 上の筋数字 */
#topNums{
  width: var(--boardW);
  display:grid;
  grid-template-columns:repeat(9, var(--cell));
  justify-content:center;
  margin: 0 auto;
}
#topNums div{
  display:flex;
  justify-content:center;
  align-items:center;
  font-weight:900;
  font-size:22px;
}

/* 盤＋左右持ち駒＋右段数字 */
#mainRow{
  display:flex;
  justify-content:center;
  align-items:flex-start;
  gap: var(--gap);
}

/* 左右持ち駒（縦） */
#handsSente, #handsGote{
  width: var(--handW);
  min-height: calc(var(--cell) * 9);
  display:flex;
  flex-direction:column;
  gap:8px;
}
#handsSente{
  justify-content:flex-start;
  flex-direction:column-reverse;
}
#handsGote{
  justify-content:flex-start;
}

.hand{
  width: calc(var(--cell) * 0.9);
  height: calc(var(--cell) * 0.9);
  border:2px solid #333;
  display:flex;
  justify-content:center;
  align-items:center;
  font-size:28px;
  font-weight:900;
  cursor:pointer;
  user-select:none;
  margin:0 auto;
}
.selected{ background:#ffe08a; }

/* 盤＋右数字 */
#boardWrap{ display:flex; }

#board{
  background:#fff8dc;
  display:grid;
  grid-template-columns:repeat(9, var(--cell));
  grid-template-rows:repeat(9, var(--cell));
  border:2px solid #333;
}
.cell{
  border:1px solid #999;
  display:flex;
  justify-content:center;
  align-items:center;
  font-size:32px;
  font-weight:900;
  cursor:pointer;
}

.sente{ transform:none; }
.gote{ transform:rotate(180deg); color:red; }

/* 右の段数字 */
#rightNums{
  display:grid;
  grid-template-rows:repeat(9, var(--cell));
  margin-left:6px;
}
#rightNums div{
  font-size:22px;
  font-weight:900;
  display:flex;
  justify-content:center;
  align-items:center;
}
</style>
</head>

<body>
<div id="app">
  <div id="stage">

    <div class="controlsWrap">
      <div class="controlsTop">
        <button onclick="onResetButton()">リセット</button>
        <button onclick="onUndoButton()">戻す</button>
      </div>

      <div class="controlsBottom">
        <button id="speedBtn" onclick="toggleSpeed()">速度：普通</button>
        <button onclick="repeatLastMove()">直前の手を復唱</button>
        <button onclick="speakHands()">持ち駒を読み上げ</button>
      </div>

      <div id="aiLevelRow">
        <button id="aiBtn1" onclick="setAILevel(1)">弱い</button>
        <button id="aiBtn2" onclick="setAILevel(2)">普通</button>
        <button id="aiBtn3" onclick="setAILevel(3)">強い</button>
        <button id="aiBtn4" onclick="setAILevel(4)">かなり強い</button>
        <button id="aiBtn5" onclick="setAILevel(5)">最強</button>
      </div>
    </div>

    <div id="topNums"></div>

    <div id="mainRow">
      <div id="handsSente"></div>

      <div id="boardWrap">
        <div id="board"></div>
        <div id="rightNums"></div>
      </div>

      <div id="handsGote"></div>
    </div>

  </div>
</div>

<script>
/* ========= 表示/読み ========= */
const nameMap={
  P:"歩",L:"香",N:"桂",S:"銀",G:"金",B:"角",R:"飛",K:"王",
  "+P":"と","+L":"と","+N":"と","+S":"全","+B":"馬","+R":"龍"
};
const readMap={
  P:"ふ",L:"きょうしゃ",N:"けいま",S:"ぎん",G:"きん",B:"かく",R:"ひしゃ",K:"おう",
  "+P":"と","+L":"と","+N":"と","+S":"ぜん","+B":"うま","+R":"りゅう"
};

/* ========= 状態 ========= */
let board,turn,selected;
let hands={sente:[], gote:[]};
let gameOver=false,winner=null;
let selectedHand=null;

let speechRate = 1.0;
const RATE_NORMAL = 1.0;
const RATE_FAST = 1.8;

let lastMove = null;

let resetPending = false;
let undoPending = false;

let undoAvailable = true;
let undoSnapshot = null;

let confirmAction = null;
let promotionPending = null;

/* ========= CPU設定 ========= */
let vsAI = true;
let aiLevel = 2;
let aiThinking = false;

function setAILevel(lv){
  aiLevel = lv;
  for(let i=1;i<=5;i++){
    const b=document.getElementById("aiBtn"+i);
    if(!b) continue;
    b.classList.toggle("aiSelected", i===lv);
  }
  const levelName = ["", "弱い", "普通", "強い", "かなり強い", "最強"];
  speak(`コンピュータの強さを${levelName[lv]}にしました。`);
}

/* ========= ユーティリティ ========= */
function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }

/* ====== 駒表現（! = 今後成れない） ====== */
function stripMeta(p){ return p ? p.replace(/!/g,"") : p; }
function hasNoPromoteFlag(p){ return !!(p && p.includes("!")); }
function coreForOwner(p){
  if(!p) return null;
  let s = stripMeta(p);
  if(s.startsWith("+")) s = s.slice(1);
  return s;
}
function ownerOf(p){
  const c = coreForOwner(p);
  if(!c) return null;
  return (c===c.toLowerCase()) ? "sente" : "gote";
}
function displayKey(p){
  if(!p) return null;
  return stripMeta(p).toUpperCase();
}
function baseKey(p){
  if(!p) return null;
  return stripMeta(p).toUpperCase().replace("+","");
}
function isPromoted(p){
  const s = stripMeta(p);
  return !!(s && s.startsWith("+"));
}
function addNoPromoteFlag(p){
  if(!p) return p;
  if(p.includes("!")) return p;
  return p + "!";
}

function speak(t){
  speechSynthesis.cancel();
  const u=new SpeechSynthesisUtterance(t);
  u.rate=speechRate;
  speechSynthesis.speak(u);
}

function clearConfirmPending(){ resetPending=false; undoPending=false; }
function clearMoveConfirm(){ confirmAction = null; }
function clearPromotionPending(){ promotionPending = null; }
function userInteracted(){ clearConfirmPending(); }

/* 人の手だけundo対象にする（CPUの手で上書きしない） */
function saveUndoSnapshot(){
  undoSnapshot={
    board: deepCopy(board),
    hands: deepCopy(hands),
    turn: turn,
    selected: null,
    selectedHand: null,
    gameOver: gameOver,
    winner: winner,
    lastMove: deepCopy(lastMove),
  };
}

/* --- リセット（2度押し） --- */
function onResetButton(){
  undoPending=false;
  clearMoveConfirm();
  clearPromotionPending();

  if(resetPending){
    resetPending=false;
    resetGame();
    return;
  }
  resetPending=true;
  speak("リセットする場合はもう一度押してください");
}

/* --- 戻す（2度押し） --- */
function onUndoButton(){
  resetPending=false;
  clearMoveConfirm();
  clearPromotionPending();

  if(!undoAvailable){
    undoPending=false;
    speak("戻す機能はすでにしようずみです");
    return;
  }
  if(!undoSnapshot){
    undoPending=false;
    speak("まだ戻せる手がありません");
    return;
  }

  if(undoPending){
    undoPending=false;
    undoMove();
    return;
  }

  undoPending=true;
  speak("戻す場合はもう一度押してください");
}

function undoMove(){
  board = deepCopy(undoSnapshot.board);
  hands = deepCopy(undoSnapshot.hands);
  turn = undoSnapshot.turn;
  selected = null;
  selectedHand = null;
  gameOver = undoSnapshot.gameOver;
  winner = undoSnapshot.winner;
  lastMove = undoSnapshot.lastMove ? deepCopy(lastMove) : null;

  undoAvailable=false;
  undoSnapshot=null;

  clearMoveConfirm();
  clearPromotionPending();
  render();
  speak(`一手戻しました。次は${turn==="sente"?"せんて":"ごて"}のばんです。`);
}

function numToKanji(n){
  const map={0:"零",1:"一",2:"二",3:"三",4:"四",5:"五",6:"六",7:"七",8:"八",9:"九",10:"十"};
  if(n<=10) return map[n];
  if(n<20) return "十"+map[n-10];
  return String(n);
}

function countHands(arr){
  const m={};
  for(const p of arr) m[p]=(m[p]||0)+1;
  return m;
}

function speakHands(){
  clearMoveConfirm();
  clearPromotionPending();
  userInteracted();
  const order=["R","B","G","S","N","L","P"];

  function sideText(side){
    const counts=countHands(hands[side]);
    const parts=[];
    for(const k of order){
      const c=counts[k]||0;
      if(c>0) parts.push(`${nameMap[k]}${numToKanji(c)}個`);
    }
    return parts.length ? parts.join("、") : "持ち駒なし";
  }

  speak(`先手は${sideText("sente")}。後手は${sideText("gote")}。`);
}

function toggleSpeed(){
  clearMoveConfirm();
  clearPromotionPending();
  userInteracted();
  const before=(speechRate===RATE_FAST)?"早い":"普通";
  speechRate=(speechRate===RATE_FAST)?RATE_NORMAL:RATE_FAST;
  const after=(speechRate===RATE_FAST)?"早い":"普通";
  document.getElementById("speedBtn").textContent=`速度：${after}`;
  speak(`速度を${before}から${after}に変更しました。`);
}

function repeatLastMove(){
  clearMoveConfirm();
  clearPromotionPending();
  userInteracted();
  if(!lastMove){ speak("まだ手がありません"); return; }
  const who=(lastMove.player==="sente")?"先手":"後手";
  speak(`${who}は${lastMove.text}`);
}

function initNums(){
  const t=document.getElementById("topNums");
  const r=document.getElementById("rightNums");
  t.innerHTML=""; r.innerHTML="";
  for(let i=9;i>=1;i--) t.innerHTML+=`<div>${i}</div>`;
  for(let i=1;i<=9;i++) r.innerHTML+=`<div>${i}</div>`;
}

function resetGame(){
  board=[
    ["L","N","S","G","K","G","S","N","L"],
    [null,"R",null,null,null,null,null,"B",null],
    ["P","P","P","P","P","P","P","P","P"],
    [null,null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null,null],
    ["p","p","p","p","p","p","p","p","p"],
    [null,"b",null,null,null,null,null,"r",null],
    ["l","n","s","g","k","g","s","n","l"]
  ];
  hands={sente:[], gote:[]};
  turn="sente";
  selected=null;
  selectedHand=null;
  gameOver=false;
  winner=null;
  lastMove=null;

  resetPending=false;
  undoPending=false;

  undoAvailable=true;
  undoSnapshot=null;

  clearMoveConfirm();
  clearPromotionPending();

  render();
  speak("リセットされました。先手の番です。");
}

/* ========= 描画 ========= */
function renderHands(){
  const s=document.getElementById("handsSente");
  const g=document.getElementById("handsGote");
  s.innerHTML=""; g.innerHTML="";

  hands.sente.forEach((p,idx)=>{
    const d=document.createElement("div");
    d.className="hand";
    d.textContent=nameMap[p];
    if(turn==="sente" && selectedHand && selectedHand.idx===idx) d.classList.add("selected");
    d.onclick=()=>onHandClick("sente", idx);

    d.ondblclick=()=>{
      if(confirmAction || promotionPending) return;
      clearMoveConfirm(); clearPromotionPending(); userInteracted();
      selectedHand=null; speak("持ち駒選択を解除しました"); render();
    };

    s.appendChild(d);
  });

  hands.gote.forEach((p,idx)=>{
    const d=document.createElement("div");
    d.className="hand gote";
    d.textContent=nameMap[p];
    if(turn==="gote" && selectedHand && selectedHand.idx===idx) d.classList.add("selected");
    d.onclick=()=>onHandClick("gote", idx);

    d.ondblclick=()=>{
      if(confirmAction || promotionPending) return;
      clearMoveConfirm(); clearPromotionPending(); userInteracted();
      selectedHand=null; speak("持ち駒選択を解除しました"); render();
    };

    g.appendChild(d);
  });
}

function render(){
  const b=document.getElementById("board");
  b.innerHTML="";
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const d=document.createElement("div");
      d.className="cell";
      const p=board[y][x];
      if(p){
        d.textContent=nameMap[displayKey(p)];
        d.classList.add(ownerOf(p)==="sente" ? "sente" : "gote");
      }
      if(selected && selected.x===x && selected.y===y) d.classList.add("selected");
      d.onclick=()=>onClick(x,y);

      d.ondblclick=()=>{
        if(confirmAction || promotionPending) return;
        clearMoveConfirm(); clearPromotionPending(); userInteracted();
        selected=null; selectedHand=null;
        speak("持ち駒選択を解除しました");
        render();
      };

      b.appendChild(d);
    }
  }
  renderHands();
}

/* ========= 入力 ========= */
function onHandClick(owner, idx){
  clearMoveConfirm();
  clearPromotionPending();
  userInteracted();
  if(gameOver){ speak(`すでにつんでいます。${winner}の勝ちです`); return; }
  if(owner!==turn){ speak("相手の持ち駒です"); return; }
  if(vsAI && turn==="gote"){ speak("コンピュータのばんです"); return; }

  selected=null;

  if(selectedHand && selectedHand.idx===idx){
    selectedHand=null;
    speak("持ち駒選択を解除しました");
    render();
    return;
  }

  const piece=hands[turn][idx];
  selectedHand={ piece, idx };
  const who=(turn==="sente")?"先手":"後手";
  speak(`${who}の持ち駒である${readMap[piece]}を選択しました`);
  render();
}

function coordText(x,y){ return `${9-x}筋${y+1}段`; }
function sideName(side){ return side==="sente" ? "先手" : "後手"; }

/* ====== クリック処理 ====== */
function onClick(x,y){
  userInteracted();

  if(gameOver){ speak(`すでにつんでいます。${winner}の勝ちです`); return; }
  if(vsAI && turn==="gote"){ speak("コンピュータのばんです"); return; }

  if(promotionPending){
    const sel = promotionPending.sel;
    const to  = promotionPending.to;

    if(x===to.x && y===to.y){
      clearPromotionPending();
      executeMove(sel, to.x, to.y, { promote:true, declined:false });
      return;
    }

    clearPromotionPending();
    executeMove(sel, to.x, to.y, { promote:false, declined:true });
    return;
  }

  if(confirmAction){
    if(confirmAction.to.x===x && confirmAction.to.y===y){
      const action = confirmAction;
      clearMoveConfirm();

      if(action.type==="drop"){
        tryDrop(action.hand, x, y);
        return;
      }
      if(action.type==="move" && selected){
        tryMove(selected, x, y);
        return;
      }
    }else{
      clearMoveConfirm();
    }
  }

  const p=board[y][x];

  if(selectedHand){
    if(board[y][x]){
      speak("そこには駒があるので置けません。選択したこまを解除します。");
      selectedHand=null;
      render();
      return;
    }

    const piece = hands[turn][selectedHand.idx];
    if(!piece){
      speak("持ち駒が見つかりません。持ち駒選択を解除しました");
      selectedHand=null;
      render();
      return;
    }

    if(isDeadSquareOnDrop(piece, turn, y)){
      speak(`${readMap[piece]}はそこには打てません。選択したこまを解除します。`);
      selectedHand=null;
      render();
      return;
    }
    if(piece==="P" && hasUnpromotedPawnInFile(turn, x)){
      speak("二歩になるので、そこには歩を打てません。選択したこまを解除します。");
      selectedHand=null;
      render();
      return;
    }

    confirmAction = { type:"drop", to:{x,y}, hand:{piece:selectedHand.piece, idx:selectedHand.idx} };
    speak(`選択した座標は${coordText(x,y)}です。${nameMap[piece]}を置きますか？`);
    return;
  }

  if(selected){
    if(selected.x===x && selected.y===y){
      selected=null;
      speak("選択を解除しました");
      render();
      return;
    }

    const mover=board[selected.y][selected.x];
    const moverOwner=ownerOf(mover);
    const target=board[y][x];

    if(target){
      const targetOwner=ownerOf(target);
      if(moverOwner===targetOwner){
        speak("自分の駒があるのでそこには指せません。選択したこまを解除します。");
        selected=null;
        render();
        return;
      }
    }

    if(!canMove(mover, selected.x, selected.y, x, y)){
      speak(`${readMap[displayKey(mover)]}はそこには進めません。選択したこまを解除します。`);
      selected=null;
      render();
      return;
    }

    confirmAction = { type:"move", from:{x:selected.x,y:selected.y}, to:{x,y} };
    if(!target){
      speak(`選択した座標は${coordText(x,y)}です。移動しますか？`);
    }else{
      const targetOwner=ownerOf(target);
      const pieceName = nameMap[displayKey(target)];
      speak(`選択した座標は${coordText(x,y)}です。${sideName(targetOwner)}の${pieceName}があります。取りますか？`);
    }
    return;
  }

  if(p){
    const owner = ownerOf(p);
    if(owner!==turn){
      const pieceName = readMap[displayKey(p)];
      speak(`そこは相手の${pieceName}で、${coordText(x,y)}です。`);
      return;
    }
    selected={x,y};
    speak(`${coordText(x,y)}の${readMap[displayKey(p)]}を選択しました`);
    render();
  } else {
    speak(`そこは${coordText(x,y)}です。`);
  }
}

/* ========= ルール ========= */
function pathClear(sx,sy,tx,ty){
  const dx=Math.sign(tx-sx), dy=Math.sign(ty-sy);
  let cx=sx+dx, cy=sy+dy;
  while(cx!==tx||cy!==ty){
    if(board[cy][cx]) return false;
    cx+=dx; cy+=dy;
  }
  return true;
}

function canMove(p,sx,sy,tx,ty){
  const pp = stripMeta(p);
  const dx=tx-sx, dy=ty-sy;
  const dir = (ownerOf(pp)==="sente") ? -1 : 1;
  const u = pp.toUpperCase();

  switch(u){
    case "P": return dx===0 && dy===dir;
    case "L": return dx===0 && dy*dir>0 && pathClear(sx,sy,tx,ty);
    case "N": return Math.abs(dx)===1 && dy===2*dir;
    case "S": return (Math.abs(dx)===1&&Math.abs(dy)===1)||(dx===0&&dy===dir);
    case "G":
    case "+P":case "+L":case "+N":case "+S":
      return (Math.abs(dx)<=1&&Math.abs(dy)<=1)&&!(Math.abs(dx)===1&&dy===-dir);
    case "B": return Math.abs(dx)===Math.abs(dy)&&pathClear(sx,sy,tx,ty);
    case "R": return (dx===0||dy===0)&&pathClear(sx,sy,tx,ty);
    case "+B": return (Math.abs(dx)===Math.abs(dy)&&pathClear(sx,sy,tx,ty))||(Math.abs(dx)<=1&&Math.abs(dy)<=1);
    case "+R": return ((dx===0||dy===0)&&pathClear(sx,sy,tx,ty))||(Math.abs(dx)<=1&&Math.abs(dy)<=1);
    case "K": return Math.abs(dx)<=1&&Math.abs(dy)<=1;
  }
  return false;
}

function opposite(side){ return side==="sente" ? "gote" : "sente"; }

function findKingPos(side){
  const k = (side==="sente") ? "k" : "K";
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p = board[y][x];
      if(!p) continue;
      const core = coreForOwner(p);
      if(core===k) return {x,y};
    }
  }
  return null;
}

function isKingInCheck(defender){
  const kp=findKingPos(defender);
  if(!kp) return false;
  const attacker=opposite(defender);

  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p=board[y][x];
      if(!p) continue;
      const owner=ownerOf(p);
      if(owner!==attacker) continue;
      if(canMove(p, x, y, kp.x, kp.y)) return true;
    }
  }
  return false;
}

function hasUnpromotedPawnInFile(owner, x){
  const pawn = (owner==="sente") ? "p" : "P";
  for(let y=0;y<9;y++){
    const p = board[y][x];
    if(!p) continue;
    const s = stripMeta(p);
    if(s===pawn) return true;
  }
  return false;
}

function isDeadSquareOnDrop(piece, owner, y){
  if(piece==="P"||piece==="L"){
    if(owner==="sente"&&y===0) return true;
    if(owner==="gote"&&y===8) return true;
  }
  if(piece==="N"){
    if(owner==="sente"&&(y===0||y===1)) return true;
    if(owner==="gote"&&(y===8||y===7)) return true;
  }
  return false;
}

/* ========= 指し手確定（人用） ========= */
function tryDrop(handSel, x, y){
  if(board[y][x]){ speak("そこには駒があるので置けません"); return; }

  const piece=hands[turn][handSel.idx];
  if(!piece){
    selectedHand=null;
    speak("持ち駒が見つかりません。持ち駒選択を解除しました");
    render();
    return;
  }

  if(isDeadSquareOnDrop(piece, turn, y)){ speak(`${readMap[piece]}はそこには打てません`); return; }
  if(piece==="P" && hasUnpromotedPawnInFile(turn, x)){ speak("二歩になるので、そこには歩を打てません"); return; }

  if(!(vsAI && turn==="gote")) saveUndoSnapshot();

  const placed=(turn==="sente")?piece.toLowerCase():piece.toUpperCase();
  board[y][x]=placed;

  const playedBy=turn;
  hands[turn].splice(handSel.idx, 1);

  selectedHand=null;
  selected=null;
  turn=(turn==="sente")?"gote":"sente";

  let moveText=`${coordText(x,y)}に${readMap[piece]}を打ちました。`;
  if(isKingInCheck(turn)) moveText+="王手です。";

  lastMove={ player: playedBy, text: moveText };

  speak(`${moveText}次は${turn==="sente"?"せんて":"ごて"}のばんです`);
  render();
  maybeAIMove();
}

function tryMove(sel,x,y){
  const p=board[sel.y][sel.x];
  const target=board[y][x];

  if(target){
    const moverOwner=ownerOf(p);
    const targetOwner=ownerOf(target);
    if(moverOwner===targetOwner){
      speak("自分の駒があるのでそこには指せません");
      return;
    }
  }

  if(!canMove(p,sel.x,sel.y,x,y)){
    speak(`${readMap[displayKey(p)]}はそこには進めません`);
    return;
  }

  const owner = ownerOf(p);
  const inZone = (owner==="sente") ? (y<=2) : (y>=6);
  const base = baseKey(p);
  const canPromote = inZone && ["P","L","N","S","B","R"].includes(base) && !isPromoted(p) && !hasNoPromoteFlag(p);

  if(canPromote){
    promotionPending = { sel: {x:sel.x,y:sel.y}, to: {x,y} };
    speak("なりますか？");
    return;
  }

  executeMove(sel, x, y, { promote:false, declined:false });
}

function executeMove(sel, x, y, opt){
  const fromPiece = board[sel.y][sel.x];
  const target = board[y][x];

  if(!fromPiece){
    selected=null;
    render();
    speak("駒が見つかりませんでした");
    return;
  }
  if(target){
    const moverOwner=ownerOf(fromPiece);
    const targetOwner=ownerOf(target);
    if(moverOwner===targetOwner){
      selected=null;
      render();
      speak("自分の駒があるのでそこには指せません");
      return;
    }
  }
  if(!canMove(fromPiece, sel.x, sel.y, x, y)){
    selected=null;
    render();
    speak(`${readMap[displayKey(fromPiece)]}はそこには進めません`);
    return;
  }

  if(!(vsAI && turn==="gote")) saveUndoSnapshot();

  if(target){
    const baseCaptured = baseKey(target);
    hands[turn].push(baseCaptured);
    if(baseCaptured==="K"){
      winner=(turn==="sente")?"先手":"後手";
      gameOver=true;
      selected=null;
      render();
      speak(`つみです。${winner}の勝ちです`);
      return;
    }
  }

  const playedBy=turn;
  const speakPieceBefore = readMap[displayKey(fromPiece)];

  let moved = fromPiece;

  let promoMsg="";
  if(opt && opt.promote){
    moved = "+" + stripMeta(fromPiece);
    promoMsg = `${readMap[baseKey(fromPiece)]}が${readMap[displayKey(moved)]}になりました。`;
  }else{
    if(opt && opt.declined){
      moved = addNoPromoteFlag(stripMeta(fromPiece));
    }
  }

  board[y][x]=moved;
  board[sel.y][sel.x]=null;
  selected=null;

  let moveText=`${coordText(x,y)}に${speakPieceBefore}を指しました。`;
  if(target) moveText+=`${readMap[displayKey(target)]}を取りました。`;
  if(promoMsg) moveText+=promoMsg;

  turn=(turn==="sente")?"gote":"sente";
  if(isKingInCheck(turn)) moveText+="王手です。";

  lastMove={ player: playedBy, text: moveText };

  if(opt && opt.declined){
    speak(`成らないを選択しました。${moveText}次は${turn==="sente"?"せんて":"ごて"}のばんです`);
  }else{
    speak(`${moveText}次は${turn==="sente"?"せんて":"ごて"}のばんです`);
  }
  render();
  maybeAIMove();
}

/* =========================================================
   ★CPU：Lv5だけ「詰み探索」+「連続王手 +2拡張」を追加
========================================================= */
const pieceValue = { P:1, L:3, N:3, S:4, G:5, B:8, R:10, K:1000 };

function valueOfPiece(p){
  if(!p) return 0;
  const b = baseKey(p);
  let v = pieceValue[b] || 0;
  if(isPromoted(p)) v += 1.8;
  return v;
}

function forwardBonus(p, y){
  const o = ownerOf(p);
  if(!o) return 0;
  const b = baseKey(p);
  if(b==="K") return 0;
  if(o==="gote"){
    return (y/8) * 0.18;
  }else{
    return ((8-y)/8) * 0.18;
  }
}

function evaluate(side){
  let s=0;
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p=board[y][x];
      if(!p) continue;
      const o=ownerOf(p);
      const v=valueOfPiece(p) + forwardBonus(p, y);
      s += (o===side)? v : -v;
    }
  }
  for(const p of hands[side]) s += (pieceValue[p]||0) * 0.95;
  for(const p of hands[opposite(side)]) s -= (pieceValue[p]||0) * 0.95;

  if(isKingInCheck(opposite(side))) s += 1.0;
  if(isKingInCheck(side)) s -= 2.0;

  return s;
}

function generatePseudoMoves(side){
  const moves = [];

  // 盤上の移動
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p = board[y][x];
      if(!p) continue;
      if(ownerOf(p) !== side) continue;

      for(let ty=0;ty<9;ty++){
        for(let tx=0;tx<9;tx++){
          if(tx===x && ty===y) continue;
          const t = board[ty][tx];
          if(t && ownerOf(t)===side) continue;
          if(!canMove(p,x,y,tx,ty)) continue;

          const base = baseKey(p);
          const inZone = (side==="sente") ? (ty<=2) : (ty>=6);
          const canPromoteHere = inZone && ["P","L","N","S","B","R"].includes(base) && !isPromoted(p) && !hasNoPromoteFlag(p);

          if(canPromoteHere){
            moves.push({type:"move", from:{x,y}, to:{x:tx,y:ty}, promote:true});
            moves.push({type:"move", from:{x,y}, to:{x:tx,y:ty}, promote:false});
          }else{
            moves.push({type:"move", from:{x,y}, to:{x:tx,y:ty}, promote:false});
          }
        }
      }
    }
  }

  // 持ち駒の打ち
  for(let i=0;i<hands[side].length;i++){
    const piece = hands[side][i];
    for(let y=0;y<9;y++){
      for(let x=0;x<9;x++){
        if(board[y][x]) continue;
        if(isDeadSquareOnDrop(piece, side, y)) continue;
        if(piece==="P" && hasUnpromotedPawnInFile(side, x)) continue;
        moves.push({type:"drop", piece, handIdx:i, to:{x,y}});
      }
    }
  }

  return moves;
}

function applyMove(m, side){
  const snapshot = {
    board: deepCopy(board),
    hands: deepCopy(hands),
    turn
  };

  if(m.type==="move"){
    const fx=m.from.x, fy=m.from.y;
    const tx=m.to.x, ty=m.to.y;
    const fromPiece = board[fy][fx];
    const target = board[ty][tx];

    if(target){
      const capBase = baseKey(target);
      hands[side].push(capBase);
    }

    let moved = fromPiece;
    if(m.promote){
      moved = "+" + stripMeta(fromPiece);
    }

    board[ty][tx] = moved;
    board[fy][fx] = null;

    m._movedTo = {x:tx,y:ty};
    m._movedPiece = moved;
    m._captured = target;

  }else{
    const tx=m.to.x, ty=m.to.y;
    const piece = hands[side][m.handIdx];
    hands[side].splice(m.handIdx,1);
    const placed = (side==="sente") ? piece.toLowerCase() : piece.toUpperCase();
    board[ty][tx] = placed;

    m._movedTo = {x:tx,y:ty};
    m._movedPiece = placed;
    m._captured = null;
  }

  turn = opposite(side);
  return snapshot;
}

function undoApply(snapshot){
  board = snapshot.board;
  hands = snapshot.hands;
  turn = snapshot.turn;
}

function isLegalAfter(m, side){
  const snap = applyMove(m, side);
  const illegal = isKingInCheck(side);
  undoApply(snap);
  return !illegal;
}

function generateLegalMoves(side){
  const pseudo = generatePseudoMoves(side);
  const legal = [];
  for(const m of pseudo){
    if(isLegalAfter(m, side)) legal.push(m);
  }
  return legal;
}

function attackersToSquare(attackerSide, tx, ty){
  const list = [];
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p=board[y][x];
      if(!p) continue;
      if(ownerOf(p)!==attackerSide) continue;
      if(canMove(p, x, y, tx, ty)) list.push({from:{x,y}, piece:p});
    }
  }
  return list;
}

// ===== Lv5用：捕獲優先順位（高いほど優先） =====
// 指定順：龍・馬・飛・角・金・銀・と・香・桂・歩
const capturePriorityRank = {
  "+R": 100, // 龍
  "+B": 95,  // 馬
  "R": 90,   // 飛
  "B": 80,   // 角
  "G": 70,   // 金
  "S": 60,   // 銀
  "+P": 55,  // と
  "+L": 55,  // 成香（と同格寄せ）
  "+N": 55,  // 成桂
  "+S": 55,  // 成銀
  "L": 40,   // 香
  "N": 35,   // 桂
  "P": 10    // 歩
};

function defendersToSquare(defenderSide, tx, ty){
  // defenderSide が (tx,ty) を守っている駒一覧
  const list = [];
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p=board[y][x];
      if(!p) continue;
      if(ownerOf(p)!==defenderSide) continue;
      if(canMove(p, x, y, tx, ty)) list.push({from:{x,y}, piece:p});
    }
  }
  return list;
}

// Lv5専用：取られやすさ（無防備を特に嫌う）
function hangingPenaltyForMoveLv5(m, moverSide){
  const to = m._movedTo;
  const movedPiece = m._movedPiece;
  if(!to || !movedPiece) return 0;

  const enemy = opposite(moverSide);
  const atks = attackersToSquare(enemy, to.x, to.y);
  if(atks.length===0) return 0;

  const defs = defendersToSquare(moverSide, to.x, to.y);
  const myV = valueOfPiece(movedPiece);

  // 「守りが0で取られる」＝最悪（Lv5は極端に嫌う）
  if(defs.length===0){
    return myV * 2.2;
  }

  // 守りがあっても危険は危険
  let minAtkV = 999;
  for(const a of atks) minAtkV = Math.min(minAtkV, valueOfPiece(a.piece));
  const cheapAttack = (minAtkV <= myV * 0.6) ? 1.0 : 0.5;

  return myV * (0.55 + 0.25*cheapAttack);
}


function captureRankOfPiece(p){
  if(!p) return 0;
  const dk = displayKey(p); // "+p!" → "+P"
  return capturePriorityRank[dk] || 0;
}


function hangingPenaltyForMove(m, moverSide){
  const to = m._movedTo;
  const movedPiece = m._movedPiece;
  if(!to || !movedPiece) return 0;

  const enemy = opposite(moverSide);
  const atks = attackersToSquare(enemy, to.x, to.y);
  if(atks.length===0) return 0;

  const myV = valueOfPiece(movedPiece);
  let minAtkV = 999;
  for(const a of atks){
    minAtkV = Math.min(minAtkV, valueOfPiece(a.piece));
  }
  const ratio = Math.max(0.2, Math.min(1.0, minAtkV / (myV+0.01)));
  return myV * (0.65 + 0.35*ratio);
}

function captureTradeBonus(m){
  if(m.type!=="move" || !m._captured) return 0;
  const capV = valueOfPiece(m._captured);
  const myV  = valueOfPiece(m._movedPiece);
  return Math.max(0, capV - myV*0.15);
}

/* ====== 手並び（αβ効かせる） ====== */
function moveOrderScore(m, side){
  let score = 0;
  const inCheckBefore = isKingInCheck(side);
  if(inCheckBefore) score += 20;

  const snap = applyMove(m, side);

  const givesCheck = isKingInCheck(opposite(side));
  if(givesCheck) score += 25;

  if(m.type==="move" && m._captured){
    score += 10 + valueOfPiece(m._captured)*2;
  }
  // ===== Lv5：捕獲優先順位を強く反映 =====
  if(aiLevel===5 && m.type==="move" && m._captured){
    const r = captureRankOfPiece(m._captured);
    score += r * 1.2;
  }

  if(m.type==="move" && m.promote) score += 8;

  score += captureTradeBonus(m);
  // ===== Lv5：無防備で取られるのを超嫌う（損判定）=====
  if(aiLevel===5){
    score -= hangingPenaltyForMoveLv5(m, side) * 1.25;
  }else{
    score -= hangingPenaltyForMove(m, side) * 0.7;
  }

  const enemyMoves = generateLegalMoves(turn);
  if(enemyMoves.length===0){
    score += 9999;
  }else{
    score += Math.max(0, 8 - enemyMoves.length) * 1.2;
  }

  undoApply(snap);
  return score;
}

/* =========================================================
   ★Lv5専用：詰み探索（王手絡みのラインだけ深掘り）
   - attacker が相手玉に王手を継続して詰ませられるか
   - 返信側は「合法手すべて」を試す（重いがLv5限定）
========================================================= */
function mateSearch(attacker, maxPlies, deadlineMs){
  if(deadlineMs && performance.now() > deadlineMs) return null;

  const defender = opposite(attacker);

  // defenderに合法手が無い
  const defMoves = generateLegalMoves(defender);
  if(defMoves.length===0){
    // 王手がかかっているなら詰み
    if(isKingInCheck(defender)) return 0; // すでに詰み
    return null; // ステイルメイト相当（将棋ではほぼ起きないが）
  }
  if(maxPlies<=0) return null;

  // attacker手番で「王手をかける手」だけ探す（詰み探索の軽量化）
  const atkMoves = generateLegalMoves(attacker);
  atkMoves.sort((a,b)=>moveOrderScore(b, attacker)-moveOrderScore(a, attacker));

  for(const m of atkMoves){
    if(deadlineMs && performance.now() > deadlineMs) return null;

    const snap = applyMove(m, attacker);
    const givesCheck = isKingInCheck(defender);

    if(!givesCheck){
      undoApply(snap);
      continue;
    }

    // 相手の全受けを試して、全部ダメなら詰み筋
    const replies = generateLegalMoves(defender);
    if(replies.length===0){
      // 王手で手なし＝詰み
      undoApply(snap);
      return 1;
    }

    let allLose = true;
    // defenderが一つでも逃げられるなら詰みじゃない
    for(const r of replies){
      if(deadlineMs && performance.now() > deadlineMs){ undoApply(snap); return null; }

      const snap2 = applyMove(r, defender);

      // 受けた後 attacker が詰ませられるか
      const res = mateSearch(attacker, maxPlies-2, deadlineMs);
      undoApply(snap2);

      if(res===null){
        allLose = false;
        break;
      }
    }

    undoApply(snap);

    if(allLose){
      return 1; // 「この手で詰み筋がある」
    }
  }

  return null;
}

/* =========================================================
   minimax：連続王手は最大+2拡張（Lv5だけ）
   checkChain = 直近の「連続王手回数」（0〜）
========================================================= */
function minimax(rootSide, depth, alpha, beta, deadlineMs, checkChain){
  if(deadlineMs && performance.now() > deadlineMs){
    return evaluate(rootSide);
  }
  if(depth===0) return evaluate(rootSide);

  const mover = turn;
  const moves = generateLegalMoves(mover);
  if(moves.length===0) return evaluate(rootSide);

  moves.sort((a,b)=> moveOrderScore(b, mover) - moveOrderScore(a, mover));

  const maximizing = (turn===rootSide);
  let best = maximizing ? -1e9 : 1e9;

  for(const m of moves){
    if(deadlineMs && performance.now() > deadlineMs) break;

    const snap = applyMove(m, mover);

    // 連続王手判定（今の手で相手が王手ならチェーン+1、違うなら0）
    const givesCheck = isKingInCheck(opposite(mover));
    const nextChain = givesCheck ? (checkChain+1) : 0;

    // Lv5のみ：連続王手が続くと最大+2まで拡張
    let extra = 0;
    if(aiLevel===5 && givesCheck){
      extra = Math.min(2, nextChain); // 1回目:+1、2回連続:+2、3回目以降も+2
    }

    const score = minimax(rootSide, depth-1+extra, alpha, beta, deadlineMs, nextChain);
    undoApply(snap);

    if(maximizing){
      if(score>best) best=score;
      if(best>alpha) alpha=best;
      if(beta<=alpha) break;
    }else{
      if(score<best) best=score;
      if(best<beta) beta=best;
      if(beta<=alpha) break;
    }
  }

  return best;
}

function maybeAIMove(){
  if(!vsAI) return;
  if(gameOver) return;
  if(turn !== "gote") return;
  if(confirmAction || promotionPending) return;
  if(aiThinking) return;

  aiThinking = true;

  setTimeout(()=>{
    try{
      doAIMove();
    } finally {
      aiThinking = false;
    }
  }, 150);
}

function aiParamsByLevel(lv){
  // Lv1〜4はほぼそのまま。Lv5だけ重くても強い方向へ。
  if(lv<=1) return {depthMax:2, noise:1.1, timeLimit:0, matePlies:0};
  if(lv===2) return {depthMax:3, noise:0.6, timeLimit:0, matePlies:0};
  if(lv===3) return {depthMax:4, noise:0.15, timeLimit:0, matePlies:0};
  if(lv===4) return {depthMax:5, noise:0.03, timeLimit:220, matePlies:0};

  // ★Lv5：重くてもOK → 深さ/時間/詰み探索を強化
  return {depthMax:8, noise:0.0, timeLimit:1800, matePlies:10}; // 詰み探索は最大10ply（=5手分）
}

function doAIMove(){
  if(gameOver) return;
  if(turn!=="gote") return;

  const {depthMax, noise, timeLimit, matePlies} = aiParamsByLevel(aiLevel);
  const deadlineMs = timeLimit ? (performance.now() + timeLimit) : null;

  let moves = generateLegalMoves("gote");
  if(moves.length===0){
    speak("コンピュータは指す手がありません。");
    return;
  }

  moves.sort((a,b)=> moveOrderScore(b, "gote") - moveOrderScore(a, "gote"));

  // Lv5は間引きしない（強さ優先）
  let candidates = moves;
  if(aiLevel<=2 && moves.length>160) candidates = moves.slice(0, aiLevel===1 ? 60 : 110);
  else if(aiLevel===3 && moves.length>260) candidates = moves.slice(0, 200);

  // ===== Lv5：取れる手が複数あるなら優先順を強制（ただし自爆は避ける）=====
  if(aiLevel===5){
    const captureMoves = candidates.filter(m => m.type==="move");
    const scoredCaps = [];
    for(const m of captureMoves){
      const snap = applyMove(m, "gote");
      const cap = m._captured;
      const givesCap = !!cap;
      let capRank = givesCap ? captureRankOfPiece(cap) : 0;

      const risk = hangingPenaltyForMoveLv5(m, "gote");
      undoApply(snap);

      if(givesCap){
        scoredCaps.push({m, capRank, risk});
      }
    }

    if(scoredCaps.length>=2){
      scoredCaps.sort((a,b)=> (b.capRank - a.capRank) || (a.risk - b.risk));
      const top = scoredCaps[0];
      if(top && top.risk < 25){
        candidates = [top.m, ...candidates.filter(x=>x!==top.m)];
      }
    }
  }

  // ===== Lv5：まず「詰み探索」だけ強化（王手絡み候補から） =====
  if(aiLevel===5 && matePlies>0){
    for(const m of candidates){
      if(deadlineMs && performance.now() > deadlineMs) break;

      const snap = applyMove(m, "gote");
      const givesCheck = isKingInCheck("sente");

      // 王手をかける手だけ詰み探索
      let mateFound = false;
      if(givesCheck){
        // すでに手なしなら即詰み
        const replies = generateLegalMoves("sente");
        if(replies.length===0 && isKingInCheck("sente")){
          mateFound = true;
        }else{
          // 本格的な「王手継続」詰み探索
          const res = mateSearch("gote", matePlies, deadlineMs);
          if(res!==null) mateFound = true;
        }
      }

      undoApply(snap);

      if(mateFound){
        // 詰み筋が見つかったら即採用
        bestMoveApplyAndSpeak(m);
        return;
      }
    }
  }

  // ===== 通常探索（反復深化なし・Lv5は深く読む） =====
  let bestMove = candidates[0];
  let bestScore = -1e9;

  for(const m of candidates){
    if(deadlineMs && performance.now() > deadlineMs) break;

    const snap = applyMove(m, "gote");
    const score = minimax("gote", Math.max(1, depthMax-1), -1e9, 1e9, deadlineMs, 0);
    undoApply(snap);

    const noisy = score + (Math.random()*2-1)*noise;
    if(noisy > bestScore){
      bestScore = noisy;
      bestMove = m;
    }
  }

  bestMoveApplyAndSpeak(bestMove);
}

function bestMoveApplyAndSpeak(bestMove){
  // ===== 実際に反映（CPUはUI確認なしで直接） =====
  if(bestMove.type==="move"){
    const fx=bestMove.from.x, fy=bestMove.from.y;
    const tx=bestMove.to.x, ty=bestMove.to.y;

    const fromPiece = board[fy][fx];
    const target = board[ty][tx];

    if(target){
      const baseCaptured = baseKey(target);
      hands.gote.push(baseCaptured);
      if(baseCaptured==="K"){
        winner="後手";
        gameOver=true;
        lastMove={ player:"gote", text:"王を取りました。" };
        render();
        speak("つみです。後手の勝ちです。");
        return;
      }
    }

    let moved = fromPiece;
    if(bestMove.promote){
      moved = "+" + stripMeta(fromPiece);
    }

    board[ty][tx]=moved;
    board[fy][fx]=null;

    turn="sente";

    const pieceName = readMap[baseKey(fromPiece)];
    let say = `${coordText(tx,ty)}に${pieceName}を指しました。`;
    if(target) say += `${readMap[displayKey(target)]}を取りました。`;
    if(bestMove.promote) say += `${pieceName}が${readMap[displayKey(moved)]}になりました。`;
    if(isKingInCheck("sente")) say += "王手です。";
    say += "次はせんてのばんです。";

    lastMove={ player:"gote", text: say.replace("次はせんてのばんです。","") };
    render();
    speak(say);

  }else{
    const x=bestMove.to.x, y=bestMove.to.y;
    const idx=bestMove.handIdx;
    const piece = hands.gote[idx];
    if(!piece) return;

    board[y][x] = piece.toUpperCase();
    hands.gote.splice(idx,1);

    turn="sente";

    let say = `${coordText(x,y)}に${readMap[piece]}を打ちました。`;
    if(isKingInCheck("sente")) say += "王手です。";
    say += "次はせんてのばんです。";

    lastMove={ player:"gote", text: say.replace("次はせんてのばんです。","") };
    render();
    speak(say);
  }
}

/* ========= 起動 ========= */
function initNums(){
  const t=document.getElementById("topNums");
  const r=document.getElementById("rightNums");
  t.innerHTML=""; r.innerHTML="";
  for(let i=9;i>=1;i--) t.innerHTML+=`<div>${i}</div>`;
  for(let i=1;i<=9;i++) r.innerHTML+=`<div>${i}</div>`;
}
initNums();
resetGame();
setAILevel(2);
</script>
</body>
</html>
