<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>しゃべる将棋（人 vs CPU）</title>

<style>
:root{
  --cell: 60px;
  --boardW: calc(var(--cell) * 9);
  --handW: 70px;
  --gap: 10px;
}
@media (max-width: 760px){ :root{ --cell: 54px; } }
@media (max-width: 650px){ :root{ --cell: 48px; } }
@media (max-width: 560px){ :root{ --cell: 42px; } }
@media (max-width: 480px){ :root{ --cell: 36px; } }

*{ box-sizing:border-box; }
body{
  font-family:sans-serif;
  margin:0;
  padding:12px;
}

#app{
  width:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
}

#stage{
  width:100%;
  display:flex;
  flex-direction:column;
  align-items:center;
}

/* コントロール全体 */
.controlsWrap{
  width: var(--boardW);
  margin: 10px auto;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.controlsWrap button{
  min-height: 90px;
  font-size: 24px;
  font-weight: 900;
}

/* 上段2つ */
.controlsTop{
  width: var(--boardW);
  display:grid;
  grid-template-columns:repeat(2, 1fr);
  gap:8px;
}

/* 中段3つ */
.controlsBottom{
  width: var(--boardW);
  display:grid;
  grid-template-columns:repeat(3, 1fr);
  gap:8px;
}

/* AIレベル行（5つ） */
#aiLevelRow{
  width: var(--boardW);
  display:grid;
  grid-template-columns:repeat(5, 1fr);
  gap:8px;
}
#aiLevelRow button{
  min-height: 70px;
  font-size: 16px;
  font-weight: 900;
}
.aiSelected{
  outline: 4px solid #ff9800;
  background: #fff3e0;
}

/* 上の筋数字 */
#topNums{
  width: var(--boardW);
  display:grid;
  grid-template-columns:repeat(9, var(--cell));
  justify-content:center;
  margin: 0 auto;
}
#topNums div{
  display:flex;
  justify-content:center;
  align-items:center;
  font-weight:900;
  font-size:22px;
}

/* 盤＋左右持ち駒＋右段数字 */
#mainRow{
  display:flex;
  justify-content:center;
  align-items:flex-start;
  gap: var(--gap);
}

/* 左右持ち駒（縦） */
#handsSente, #handsGote{
  width: var(--handW);
  min-height: calc(var(--cell) * 9);
  display:flex;
  flex-direction:column;
  gap:8px;
}
#handsSente{
  justify-content:flex-start;
  flex-direction:column-reverse;
}
#handsGote{
  justify-content:flex-start;
}

.hand{
  width: calc(var(--cell) * 0.9);
  height: calc(var(--cell) * 0.9);
  border:2px solid #333;
  display:flex;
  justify-content:center;
  align-items:center;
  font-size:28px;
  font-weight:900;
  cursor:pointer;
  user-select:none;
  margin:0 auto;
}
.selected{ background:#ffe08a; }

/* 盤＋右数字 */
#boardWrap{ display:flex; }

#board{
  background:#fff8dc;
  display:grid;
  grid-template-columns:repeat(9, var(--cell));
  grid-template-rows:repeat(9, var(--cell));
  border:2px solid #333;
}
.cell{
  border:1px solid #999;
  display:flex;
  justify-content:center;
  align-items:center;
  font-size:32px;
  font-weight:900;
  cursor:pointer;
}

.sente{ transform:none; }
.gote{ transform:rotate(180deg); color:red; }

/* 右の段数字 */
#rightNums{
  display:grid;
  grid-template-rows:repeat(9, var(--cell));
  margin-left:6px;
}
#rightNums div{
  font-size:22px;
  font-weight:900;
  display:flex;
  justify-content:center;
  align-items:center;
}
#versionLabel{
  position: fixed;
  top: 6px;
  left: 8px;
  background: rgba(0,0,0,0.75);
  color: white;
  font-size: 14px;
  font-weight: bold;
  padding: 4px 10px;
  border-radius: 8px;
  z-index: 9999;
}
</style>
</head>

<body>
<!-- =========================================== -->
<!-- ============【★バージョン記載】============= -->
<!-- =========================================== -->
<div id="versionLabel">
  Ver 1.0.6（2026.02.17 22:05） 
</div>

<div id="app">
  <div id="stage">

    <div class="controlsWrap">
      <div class="controlsTop">
        <button onclick="onResetButton()">リセット</button>
        <button onclick="onUndoButton()">戻す</button>
      </div>

      <div class="controlsBottom">
        <button id="speedBtn" onclick="toggleSpeed()">速度：普通</button>
        <button onclick="repeatLastMove()">直前の手を復唱</button>
        <button onclick="speakHands()">持ち駒を読み上げ</button>
      </div>

      <div id="aiLevelRow">
        <button id="aiBtn1" onclick="setAILevel(1)">弱い</button>
        <button id="aiBtn2" onclick="setAILevel(2)">普通</button>
        <button id="aiBtn3" onclick="setAILevel(3)">強い</button>
        <button id="aiBtn4" onclick="setAILevel(4)">かなり強い</button>
        <button id="aiBtn5" onclick="setAILevel(5)">最強</button>
      </div>
    </div>

    <div id="topNums"></div>

    <div id="mainRow">
      <div id="handsSente"></div>

      <div id="boardWrap">
        <div id="board"></div>
        <div id="rightNums"></div>
      </div>

      <div id="handsGote"></div>
    </div>

  </div>
</div>

<script>
/* ========= 表示/読み ========= */
const nameMap={
  P:"歩",L:"香",N:"桂",S:"銀",G:"金",B:"角",R:"飛",K:"王",
  "+P":"と","+L":"と","+N":"と","+S":"全","+B":"馬","+R":"龍"
};
const readMap={
  P:"ふ",L:"きょうしゃ",N:"けいま",S:"ぎん",G:"きん",B:"かく",R:"ひしゃ",K:"おう",
  "+P":"と","+L":"と","+N":"と","+S":"ぜん","+B":"うま","+R":"りゅう"
};

/* ========= 状態 ========= */
let board,turn,selected;
let hands={sente:[], gote:[]};
let gameOver=false,winner=null;
let selectedHand=null;

let speechRate = 1.0;
const RATE_NORMAL = 1.0;
const RATE_FAST = 1.8;

let lastMove = null;

let resetPending = false;
let undoPending = false;

let undoAvailable = true;
let undoSnapshot = null;

let confirmAction = null;
let promotionPending = null;

/* ========= CPU設定 ========= */
let vsAI = true;
let aiLevel = 2;
let aiThinking = false;

function setAILevel(lv){
  aiLevel = lv;
  for(let i=1;i<=5;i++){
    const b=document.getElementById("aiBtn"+i);
    if(!b) continue;
    b.classList.toggle("aiSelected", i===lv);
  }
  const levelName = ["", "弱い", "普通", "強い", "かなり強い", "最強"];
  speak(`コンピュータの強さを${levelName[lv]}にしました。`);
}

/* ========= ユーティリティ ========= */
function deepCopy(obj){ return JSON.parse(JSON.stringify(obj)); }

/* ====== 駒表現（! = 今後成れない） ====== */
function stripMeta(p){ return p ? p.replace(/!/g,"") : p; }
function hasNoPromoteFlag(p){ return !!(p && p.includes("!")); }
function coreForOwner(p){
  if(!p) return null;
  let s = stripMeta(p);
  if(s.startsWith("+")) s = s.slice(1);
  return s;
}
function ownerOf(p){
  const c = coreForOwner(p);
  if(!c) return null;
  return (c===c.toLowerCase()) ? "sente" : "gote";
}
function displayKey(p){
  if(!p) return null;
  return stripMeta(p).toUpperCase();
}
function baseKey(p){
  if(!p) return null;
  return stripMeta(p).toUpperCase().replace("+","");
}
function isPromoted(p){
  const s = stripMeta(p);
  return !!(s && s.startsWith("+"));
}
function addNoPromoteFlag(p){
  if(!p) return p;
  if(p.includes("!")) return p;
  return p + "!";
}

function speak(t){
  speechSynthesis.cancel();
  const u=new SpeechSynthesisUtterance(t);
  u.rate=speechRate;
  speechSynthesis.speak(u);
}

function clearConfirmPending(){ resetPending=false; undoPending=false; }
function clearMoveConfirm(){ confirmAction = null; }
function clearPromotionPending(){ promotionPending = null; }
function userInteracted(){ clearConfirmPending(); }

/* 人の手だけundo対象にする（CPUの手で上書きしない） */
function saveUndoSnapshot(){
  undoSnapshot={
    board: deepCopy(board),
    hands: deepCopy(hands),
    turn: turn,
    selected: null,
    selectedHand: null,
    gameOver: gameOver,
    winner: winner,
    lastMove: deepCopy(lastMove),
  };
}

/* --- リセット（2度押し） --- */
function onResetButton(){
  undoPending=false;
  clearMoveConfirm();
  clearPromotionPending();

  if(resetPending){
    resetPending=false;
    resetGame();
    return;
  }
  resetPending=true;
  speak("リセットする場合はもう一度押してください");
}

/* --- 戻す（2度押し） --- */
function onUndoButton(){
  resetPending=false;
  clearMoveConfirm();
  clearPromotionPending();

  if(!undoAvailable){
    undoPending=false;
    speak("戻す機能はすでにしようずみです");
    return;
  }
  if(!undoSnapshot){
    undoPending=false;
    speak("まだ戻せる手がありません");
    return;
  }

  if(undoPending){
    undoPending=false;
    undoMove();
    return;
  }

  undoPending=true;
  speak("戻す場合はもう一度押してください");
}

function undoMove(){
  board = deepCopy(undoSnapshot.board);
  hands = deepCopy(undoSnapshot.hands);
  turn = undoSnapshot.turn;
  selected = null;
  selectedHand = null;
  gameOver = undoSnapshot.gameOver;
  winner = undoSnapshot.winner;
  lastMove = undoSnapshot.lastMove ? deepCopy(lastMove) : null;

  undoAvailable=false;
  undoSnapshot=null;

  clearMoveConfirm();
  clearPromotionPending();
  render();
  speak(`一手戻しました。次は${turn==="sente"?"せんて":"ごて"}のばんです。`);
}

function numToKanji(n){
  const map={0:"零",1:"一",2:"二",3:"三",4:"四",5:"五",6:"六",7:"七",8:"八",9:"九",10:"十"};
  if(n<=10) return map[n];
  if(n<20) return "十"+map[n-10];
  return String(n);
}

function countHands(arr){
  const m={};
  for(const p of arr) m[p]=(m[p]||0)+1;
  return m;
}

function speakHands(){
  clearMoveConfirm();
  clearPromotionPending();
  userInteracted();
  const order=["R","B","G","S","N","L","P"];

  function sideText(side){
    const counts=countHands(hands[side]);
    const parts=[];
    for(const k of order){
      const c=counts[k]||0;
      if(c>0) parts.push(`${nameMap[k]}${numToKanji(c)}個`);
    }
    return parts.length ? parts.join("、") : "持ち駒なし";
  }

  speak(`先手は${sideText("sente")}。後手は${sideText("gote")}。`);
}

function toggleSpeed(){
  clearMoveConfirm();
  clearPromotionPending();
  userInteracted();
  const before=(speechRate===RATE_FAST)?"早い":"普通";
  speechRate=(speechRate===RATE_FAST)?RATE_NORMAL:RATE_FAST;
  const after=(speechRate===RATE_FAST)?"早い":"普通";
  document.getElementById("speedBtn").textContent=`速度：${after}`;
  speak(`速度を${before}から${after}に変更しました。`);
}

function repeatLastMove(){
  clearMoveConfirm();
  clearPromotionPending();
  userInteracted();
  if(!lastMove){ speak("まだ手がありません"); return; }
  const who=(lastMove.player==="sente")?"先手":"後手";
  speak(`${who}は${lastMove.text}`);
}

function initNums(){
  const t=document.getElementById("topNums");
  const r=document.getElementById("rightNums");
  t.innerHTML=""; r.innerHTML="";
  for(let i=9;i>=1;i--) t.innerHTML+=`<div>${i}</div>`;
  for(let i=1;i<=9;i++) r.innerHTML+=`<div>${i}</div>`;
}

function resetGame(){
  board=[
    ["L","N","S","G","K","G","S","N","L"],
    [null,"R",null,null,null,null,null,"B",null],
    ["P","P","P","P","P","P","P","P","P"],
    [null,null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null,null],
    ["p","p","p","p","p","p","p","p","p"],
    [null,"b",null,null,null,null,null,"r",null],
    ["l","n","s","g","k","g","s","n","l"]
  ];
  hands={sente:[], gote:[]};
  turn="sente";
  selected=null;
  selectedHand=null;
  gameOver=false;
  winner=null;
  lastMove=null;

  resetPending=false;
  undoPending=false;

  undoAvailable=true;
  undoSnapshot=null;

  clearMoveConfirm();
  clearPromotionPending();

  render();
  speak("リセットされました。先手の番です。");
}

/* ========= 描画 ========= */
function renderHands(){
  const s=document.getElementById("handsSente");
  const g=document.getElementById("handsGote");
  s.innerHTML=""; g.innerHTML="";

  hands.sente.forEach((p,idx)=>{
    const d=document.createElement("div");
    d.className="hand";
    d.textContent=nameMap[p];
    if(turn==="sente" && selectedHand && selectedHand.idx===idx) d.classList.add("selected");
    d.onclick=()=>onHandClick("sente", idx);

    d.ondblclick=()=>{
      if(confirmAction || promotionPending) return;
      clearMoveConfirm(); clearPromotionPending(); userInteracted();
      selectedHand=null; speak("持ち駒選択を解除しました"); render();
    };

    s.appendChild(d);
  });

  hands.gote.forEach((p,idx)=>{
    const d=document.createElement("div");
    d.className="hand gote";
    d.textContent=nameMap[p];
    if(turn==="gote" && selectedHand && selectedHand.idx===idx) d.classList.add("selected");
    d.onclick=()=>onHandClick("gote", idx);

    d.ondblclick=()=>{
      if(confirmAction || promotionPending) return;
      clearMoveConfirm(); clearPromotionPending(); userInteracted();
      selectedHand=null; speak("持ち駒選択を解除しました"); render();
    };

    g.appendChild(d);
  });
}

function render(){
  const b=document.getElementById("board");
  b.innerHTML="";
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const d=document.createElement("div");
      d.className="cell";
      const p=board[y][x];
      if(p){
        d.textContent=nameMap[displayKey(p)];
        d.classList.add(ownerOf(p)==="sente" ? "sente" : "gote");
      }
      if(selected && selected.x===x && selected.y===y) d.classList.add("selected");
      d.onclick=()=>onClick(x,y);

      d.ondblclick=()=>{
        if(confirmAction || promotionPending) return;
        clearMoveConfirm(); clearPromotionPending(); userInteracted();
        selected=null; selectedHand=null;
        speak("持ち駒選択を解除しました");
        render();
      };

      b.appendChild(d);
    }
  }
  renderHands();
}

/* ========= 入力 ========= */
function onHandClick(owner, idx){
  clearMoveConfirm();
  clearPromotionPending();
  userInteracted();
  if(gameOver){ speak(`すでにつんでいます。${winner}の勝ちです`); return; }
  if(owner!==turn){ speak("相手の持ち駒です"); return; }
  if(vsAI && turn==="gote"){ speak("コンピュータのばんです"); return; }

  selected=null;

  if(selectedHand && selectedHand.idx===idx){
    selectedHand=null;
    speak("持ち駒選択を解除しました");
    render();
    return;
  }

  const piece=hands[turn][idx];
  selectedHand={ piece, idx };
  const who=(turn==="sente")?"先手":"後手";
  speak(`${who}の持ち駒である${readMap[piece]}を選択しました`);
  render();
}

function coordText(x,y){ return `${9-x}筋${y+1}段`; }
function sideName(side){ return side==="sente" ? "先手" : "後手"; }

/* ====== クリック処理 ====== */
function onClick(x,y){
  userInteracted();

  if(gameOver){ speak(`すでにつんでいます。${winner}の勝ちです`); return; }
  if(vsAI && turn==="gote"){ speak("コンピュータのばんです"); return; }

  if(promotionPending){
    const sel = promotionPending.sel;
    const to  = promotionPending.to;

    if(x===to.x && y===to.y){
      clearPromotionPending();
      executeMove(sel, to.x, to.y, { promote:true, declined:false });
      return;
    }

    clearPromotionPending();
    executeMove(sel, to.x, to.y, { promote:false, declined:true });
    return;
  }

  if(confirmAction){
    if(confirmAction.to.x===x && confirmAction.to.y===y){
      const action = confirmAction;
      clearMoveConfirm();

      if(action.type==="drop"){
        tryDrop(action.hand, x, y);
        return;
      }
      if(action.type==="move" && selected){
        tryMove(selected, x, y);
        return;
      }
    }else{
      clearMoveConfirm();
    }
  }

  const p=board[y][x];

  if(selectedHand){
    if(board[y][x]){
      speak("そこには駒があるので置けません。選択したこまを解除します。");
      selectedHand=null;
      render();
      return;
    }

    const piece = hands[turn][selectedHand.idx];
    if(!piece){
      speak("持ち駒が見つかりません。持ち駒選択を解除しました");
      selectedHand=null;
      render();
      return;
    }

    if(isDeadSquareOnDrop(piece, turn, y)){
      speak(`${readMap[piece]}はそこには打てません。選択したこまを解除します。`);
      selectedHand=null;
      render();
      return;
    }
    if(piece==="P" && hasUnpromotedPawnInFile(turn, x)){
      speak("二歩になるので、そこには歩を打てません。選択したこまを解除します。");
      selectedHand=null;
      render();
      return;
    }

    confirmAction = { type:"drop", to:{x,y}, hand:{piece:selectedHand.piece, idx:selectedHand.idx} };
    speak(`選択した座標は${coordText(x,y)}です。${nameMap[piece]}を置きますか？`);
    return;
  }

  if(selected){
    if(selected.x===x && selected.y===y){
      selected=null;
      speak("選択を解除しました");
      render();
      return;
    }

    const mover=board[selected.y][selected.x];
    const moverOwner=ownerOf(mover);
    const target=board[y][x];

    if(target){
      const targetOwner=ownerOf(target);
      if(moverOwner===targetOwner){
        speak("自分の駒があるのでそこには指せません。選択したこまを解除します。");
        selected=null;
        render();
        return;
      }
    }

    if(!canMove(mover, selected.x, selected.y, x, y)){
      speak(`${readMap[displayKey(mover)]}はそこには進めません。選択したこまを解除します。`);
      selected=null;
      render();
      return;
    }

    confirmAction = { type:"move", from:{x:selected.x,y:selected.y}, to:{x,y} };
    if(!target){
      speak(`選択した座標は${coordText(x,y)}です。移動しますか？`);
    }else{
      const targetOwner=ownerOf(target);
      const pieceName = nameMap[displayKey(target)];
      speak(`選択した座標は${coordText(x,y)}です。${sideName(targetOwner)}の${pieceName}があります。取りますか？`);
    }
    return;
  }

  if(p){
    const owner = ownerOf(p);
    if(owner!==turn){
      const pieceName = readMap[displayKey(p)];
      speak(`そこは相手の${pieceName}で、${coordText(x,y)}です。`);
      return;
    }
    selected={x,y};
    speak(`${coordText(x,y)}の${readMap[displayKey(p)]}を選択しました`);
    render();
  } else {
    speak(`そこは${coordText(x,y)}です。`);
  }
}

/* ========= ルール ========= */
function pathClear(sx,sy,tx,ty){
  const dx=Math.sign(tx-sx), dy=Math.sign(ty-sy);
  let cx=sx+dx, cy=sy+dy;
  while(cx!==tx||cy!==ty){
    if(board[cy][cx]) return false;
    cx+=dx; cy+=dy;
  }
  return true;
}

function canMove(p,sx,sy,tx,ty){
  const pp = stripMeta(p);
  const dx=tx-sx, dy=ty-sy;
  const dir = (ownerOf(pp)==="sente") ? -1 : 1;
  const u = pp.toUpperCase();

  switch(u){
    case "P": return dx===0 && dy===dir;
    case "L": return dx===0 && dy*dir>0 && pathClear(sx,sy,tx,ty);
    case "N": return Math.abs(dx)===1 && dy===2*dir;
    case "S": return (Math.abs(dx)===1&&Math.abs(dy)===1)||(dx===0&&dy===dir);
    case "G":
    case "+P":case "+L":case "+N":case "+S":
      return (Math.abs(dx)<=1&&Math.abs(dy)<=1)&&!(Math.abs(dx)===1&&dy===-dir);
    case "B": return Math.abs(dx)===Math.abs(dy)&&pathClear(sx,sy,tx,ty);
    case "R": return (dx===0||dy===0)&&pathClear(sx,sy,tx,ty);
    case "+B": return (Math.abs(dx)===Math.abs(dy)&&pathClear(sx,sy,tx,ty))||(Math.abs(dx)<=1&&Math.abs(dy)<=1);
    case "+R": return ((dx===0||dy===0)&&pathClear(sx,sy,tx,ty))||(Math.abs(dx)<=1&&Math.abs(dy)<=1);
    case "K": return Math.abs(dx)<=1&&Math.abs(dy)<=1;
  }
  return false;
}

function opposite(side){ return side==="sente" ? "gote" : "sente"; }

function findKingPos(side){
  const k = (side==="sente") ? "k" : "K";
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p = board[y][x];
      if(!p) continue;
      const core = coreForOwner(p);
      if(core===k) return {x,y};
    }
  }
  return null;
}

function isKingInCheck(defender){
  const kp=findKingPos(defender);
  if(!kp) return false;
  const attacker=opposite(defender);

  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p=board[y][x];
      if(!p) continue;
      const owner=ownerOf(p);
      if(owner!==attacker) continue;
      if(canMove(p, x, y, kp.x, kp.y)) return true;
    }
  }
  return false;
}

function hasUnpromotedPawnInFile(owner, x){
  const pawn = (owner==="sente") ? "p" : "P";
  for(let y=0;y<9;y++){
    const p = board[y][x];
    if(!p) continue;
    const s = stripMeta(p);
    if(s===pawn) return true;
  }
  return false;
}

function isDeadSquareOnDrop(piece, owner, y){
  if(piece==="P"||piece==="L"){
    if(owner==="sente"&&y===0) return true;
    if(owner==="gote"&&y===8) return true;
  }
  if(piece==="N"){
    if(owner==="sente"&&(y===0||y===1)) return true;
    if(owner==="gote"&&(y===8||y===7)) return true;
  }
  return false;
}

/* ========= 指し手確定（人用） ========= */
function tryDrop(handSel, x, y){
  if(board[y][x]){ speak("そこには駒があるので置けません"); return; }

  const piece=hands[turn][handSel.idx];
  if(!piece){
    selectedHand=null;
    speak("持ち駒が見つかりません。持ち駒選択を解除しました");
    render();
    return;
  }

  if(isDeadSquareOnDrop(piece, turn, y)){ speak(`${readMap[piece]}はそこには打てません`); return; }
  if(piece==="P" && hasUnpromotedPawnInFile(turn, x)){ speak("二歩になるので、そこには歩を打てません"); return; }

  if(!(vsAI && turn==="gote")) saveUndoSnapshot();

  const placed=(turn==="sente")?piece.toLowerCase():piece.toUpperCase();
  board[y][x]=placed;

  const playedBy=turn;
  hands[turn].splice(handSel.idx, 1);

  selectedHand=null;
  selected=null;
  turn=(turn==="sente")?"gote":"sente";

  let moveText=`${coordText(x,y)}に${readMap[piece]}を打ちました。`;
  if(isKingInCheck(turn)) moveText+="王手です。";

  lastMove={ player: playedBy, text: moveText };

  speak(`${moveText}次は${turn==="sente"?"せんて":"ごて"}のばんです`);
  render();
  maybeAIMove();
}

/* =========================================================
   1) 成り判定：移動元or移動先が敵陣
   2) 強制成り
   ※ 人側もルール整合のため同じ判定を使う
========================================================= */
function inPromoteZone(side, y){ return (side==="sente") ? (y<=2) : (y>=6); }
function canPromoteByFromTo(side, fromY, toY){ return inPromoteZone(side, fromY) || inPromoteZone(side, toY); }
function mustPromote(base, side, toY){
  if(base==="P" || base==="L"){
    return (side==="sente") ? (toY===0) : (toY===8);
  }
  if(base==="N"){
    return (side==="sente") ? (toY<=1) : (toY>=7);
  }
  return false;
}

function tryMove(sel,x,y){
  const p=board[sel.y][sel.x];
  const target=board[y][x];

  if(target){
    const moverOwner=ownerOf(p);
    const targetOwner=ownerOf(target);
    if(moverOwner===targetOwner){
      speak("自分の駒があるのでそこには指せません");
      return;
    }
  }

  if(!canMove(p,sel.x,sel.y,x,y)){
    speak(`${readMap[displayKey(p)]}はそこには進めません`);
    return;
  }

  const owner = ownerOf(p);
  const base = baseKey(p);

  const promotable = ["P","L","N","S","B","R"].includes(base) && !isPromoted(p) && !hasNoPromoteFlag(p);
  const canPromote = promotable && canPromoteByFromTo(owner, sel.y, y);
  const must = promotable && mustPromote(base, owner, y);

  if(canPromote){
    if(must){
      executeMove(sel, x, y, { promote:true, declined:false });
      return;
    }
    promotionPending = { sel: {x:sel.x,y:sel.y}, to: {x,y} };
    speak("なりますか？");
    return;
  }

  executeMove(sel, x, y, { promote:false, declined:false });
}

function executeMove(sel, x, y, opt){
  const fromPiece = board[sel.y][sel.x];
  const target = board[y][x];

  if(!fromPiece){
    selected=null;
    render();
    speak("駒が見つかりませんでした");
    return;
  }
  if(target){
    const moverOwner=ownerOf(fromPiece);
    const targetOwner=ownerOf(target);
    if(moverOwner===targetOwner){
      selected=null;
      render();
      speak("自分の駒があるのでそこには指せません");
      return;
    }
  }
  if(!canMove(fromPiece, sel.x, sel.y, x, y)){
    selected=null;
    render();
    speak(`${readMap[displayKey(fromPiece)]}はそこには進めません`);
    return;
  }

  if(!(vsAI && turn==="gote")) saveUndoSnapshot();

  if(target){
    const baseCaptured = baseKey(target);
    hands[turn].push(baseCaptured);
    if(baseCaptured==="K"){
      winner=(turn==="sente")?"先手":"後手";
      gameOver=true;
      selected=null;
      render();
      speak(`つみです。${winner}の勝ちです`);
      return;
    }
  }

  const playedBy=turn;
  const speakPieceBefore = readMap[displayKey(fromPiece)];

  let moved = fromPiece;

  let promoMsg="";
  if(opt && opt.promote){
    moved = "+" + stripMeta(fromPiece);
    promoMsg = `${readMap[baseKey(fromPiece)]}が${readMap[displayKey(moved)]}になりました。`;
  }else{
    if(opt && opt.declined){
      moved = addNoPromoteFlag(stripMeta(fromPiece));
    }
  }

  board[y][x]=moved;
  board[sel.y][sel.x]=null;
  selected=null;

  let moveText=`${coordText(x,y)}に${speakPieceBefore}を指しました。`;
  if(target) moveText+=`${readMap[displayKey(target)]}を取りました。`;
  if(promoMsg) moveText+=promoMsg;

  turn=(turn==="sente")?"gote":"sente";
  if(isKingInCheck(turn)) moveText+="王手です。";

  lastMove={ player: playedBy, text: moveText };

  if(opt && opt.declined){
    speak(`成らないを選択しました。${moveText}次は${turn==="sente"?"せんて":"ごて"}のばんです`);
  }else{
    speak(`${moveText}次は${turn==="sente"?"せんて":"ごて"}のばんです`);
  }
  render();
  maybeAIMove();
}

/* =========================================================
   定跡ブック（book.json）読み込み＆局面一致で優先
   ※ UI/音声は変更しない（喋りは従来通りbestMoveApplyAndSpeakのみ）
========================================================= */
let OPENING_BOOK = {}; // posKey -> [{m:{...}, w:number}, ...]
let bookLoaded = false;

// ===== ブック生成用：無音初期化（UI/音声に影響なし）=====
function silentResetToStart(){
  board=[
    ["L","N","S","G","K","G","S","N","L"],
    [null,"R",null,null,null,null,null,"B",null],
    ["P","P","P","P","P","P","P","P","P"],
    [null,null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null,null],
    ["p","p","p","p","p","p","p","p","p"],
    [null,"b",null,null,null,null,null,"r",null],
    ["l","n","s","g","k","g","s","n","l"]
  ];
  hands={sente:[], gote:[]};
  turn="sente";
}

function addBookMove(posKey, moveObj, w=1){
  if(!OPENING_BOOK[posKey]) OPENING_BOOK[posKey]=[];
  const list = OPENING_BOOK[posKey];
  const s = JSON.stringify(moveObj);
  const found = list.find(e => JSON.stringify(e.m)===s);
  if(found) found.w += w;
  else list.push({m: moveObj, w});
}

function applyLineMove(mv){
  // mv: {type:"move", from:{x,y}, to:{x,y}, promote:false} or {type:"drop", piece:"P", to:{x,y}}
  if(mv.type==="move"){
    const fx=mv.from.x, fy=mv.from.y;
    const tx=mv.to.x, ty=mv.to.y;
    const fromPiece = board[fy][fx];
    if(!fromPiece) throw new Error("fromPiece missing");

    const target = board[ty][tx];
    if(target){
      const capBase = baseKey(target);
      hands[turn].push(capBase);
    }

    let moved = fromPiece;
    if(mv.promote){
      moved = "+" + stripMeta(fromPiece);
    }
    board[ty][tx]=moved;
    board[fy][fx]=null;
    turn = opposite(turn);
    return;
  }

  // drop
  const x=mv.to.x, y=mv.to.y;
  const idx = hands[turn].indexOf(mv.piece);
  if(idx<0) throw new Error("drop piece not in hand");
  hands[turn].splice(idx,1);
  board[y][x] = (turn==="sente") ? mv.piece.toLowerCase() : mv.piece.toUpperCase();
  turn = opposite(turn);
}

function buildBookFromLines(lines){
  OPENING_BOOK = {}; // 作り直し
  for(const line of lines){
    silentResetToStart();
    for(const mv of line.moves){
      // いまの局面をキーにして “次の手” を登録
      const key = positionKey();

      // ブック登録用に正規化（dropはhandIdxではなくpieceだけ）
      let bookMv;
      if(mv.type==="move"){
        bookMv = {type:"move", from:mv.from, to:mv.to, promote:!!mv.promote};
      }else{
        bookMv = {type:"drop", piece:mv.piece, to:mv.to};
      }

      addBookMove(key, bookMv, 1);

      // 実局面に適用（無音）
      applyLineMove(mv);
    }
  }
}

// ★まず動作確認：最低限の定跡（2手だけ）
const FAMOUS_OPENING_LINES = [
  {
    name: "test",
    moves: [
      {type:"move", from:{x:2,y:6}, to:{x:2,y:5}, promote:false}, // ▲7六歩
      {type:"move", from:{x:6,y:2}, to:{x:6,y:3}, promote:false}  // △3四歩
    ]
  }
];

function generateBookJsonToConsole(){
  buildBookFromLines(FAMOUS_OPENING_LINES);
  // そのまま book.json に保存できる形
  console.log(JSON.stringify(OPENING_BOOK));
  console.log("✅ 生成OK：上のJSONを book.json として保存し、index.html と同じフォルダへ置いてください（GitHub Pages推奨）");
}

function positionKey(){
  const rows = [];
  for(let y=0;y<9;y++){
    let r="";
    for(let x=0;x<9;x++){
      const p = board[y][x];
      r += p ? stripMeta(p) : ".";
      r += ",";
    }
    rows.push(r);
  }
  function handCounts(side){
    const order=["R","B","G","S","N","L","P"];
    const c = {R:0,B:0,G:0,S:0,N:0,L:0,P:0};
    for(const p of hands[side]) c[p]=(c[p]||0)+1;
    return order.map(k=>k+String(c[k]||0)).join("");
  }
  return `t:${turn}|b:${rows.join("/")}|hs:${handCounts("sente")}|hg:${handCounts("gote")}`;
}

function weightedPick(list){
  let sum=0;
  for(const e of list) sum += (e.w||1);
  let r = Math.random()*sum;
  for(const e of list){
    r -= (e.w||1);
    if(r<=0) return e.m;
  }
  return list[list.length-1].m;
}

function pickBookMoveForSide(side){
  if(!bookLoaded) return null;
  const key = positionKey();
  const list = OPENING_BOOK[key];
  if(!list || list.length===0) return null;

  const probByLv = {1:0.30, 2:0.30, 3:0.30, 4:0.30, 5:0.30};
  const p = probByLv[aiLevel] ?? 0.75;
  if(Math.random() > p) return null;

  const bm = weightedPick(list);

  if(bm.type==="drop"){
    const idx = hands[side].indexOf(bm.piece);
    if(idx<0) return null;
    return {type:"drop", piece: bm.piece, handIdx: idx, to: bm.to};
  }
  return bm;
}

async function loadBookJson(url="./book.json"){
  try{
    const res = await fetch(url, {cache:"no-store"});
    if(!res.ok) { bookLoaded=false; return false; }
    const obj = await res.json();
    if(obj && typeof obj==="object"){
      OPENING_BOOK = obj;
      bookLoaded = true;
      return true;
    }
    bookLoaded=false;
    return false;
  }catch(e){
    bookLoaded=false;
    return false;
  }
}

/* =========================================================
   ★CPU強化：前回の「1〜5」を完全統合（探索/静止探索/玉評価/反復深化）
========================================================= */

const pieceValue = { P:1, L:3, N:3, S:4, G:5, B:8, R:10, K:1000 };

function valueOfPiece(p){
  if(!p) return 0;
  const b = baseKey(p);
  let v = pieceValue[b] || 0;
  if(isPromoted(p)) v += 1.8;
  return v;
}

function forwardBonus(p, y){
  const o = ownerOf(p);
  if(!o) return 0;
  const b = baseKey(p);
  if(b==="K") return 0;
  if(o==="gote"){
    return (y/8) * 0.18;
  }else{
    return ((8-y)/8) * 0.18;
  }
}

/* ===== 4) 玉の危険度（簡易） ===== */
function attackersToSquare(attackerSide, tx, ty){
  const list = [];
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p=board[y][x];
      if(!p) continue;
      if(ownerOf(p)!==attackerSide) continue;
      if(canMove(p, x, y, tx, ty)) list.push({from:{x,y}, piece:p});
    }
  }
  return list;
}
function defendersToSquare(defenderSide, tx, ty){
  const list = [];
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p=board[y][x];
      if(!p) continue;
      if(ownerOf(p)!==defenderSide) continue;
      if(canMove(p, x, y, tx, ty)) list.push({from:{x,y}, piece:p});
    }
  }
  return list;
}

function kingSafetyScore(side){
  const kp = findKingPos(side);
  if(!kp) return 0;

  const enemy = opposite(side);
  let danger = 0;
  let cover = 0;

  for(let dy=-1; dy<=1; dy++){
    for(let dx=-1; dx<=1; dx++){
      if(dx===0 && dy===0) continue;
      const x = kp.x + dx;
      const y = kp.y + dy;
      if(x<0||x>8||y<0||y>8) continue;

      const atks = attackersToSquare(enemy, x, y);
      danger += atks.length * 1.2;

      const p = board[y][x];
      if(p && ownerOf(p)===side){
        const dk = displayKey(p);
        if(dk==="G" || dk==="S" || dk==="+P" || dk==="+L" || dk==="+N" || dk==="+S"){
          cover += 1.1;
        }else if(dk==="K"){
          cover += 0.2;
        }
      }
    }
  }

  if(isKingInCheck(side)) danger += 6.0;
  return cover - danger;
}

function evaluate(side){
  let s=0;
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p=board[y][x];
      if(!p) continue;
      const o=ownerOf(p);
      const v=valueOfPiece(p) + forwardBonus(p, y);
      s += (o===side)? v : -v;
    }
  }
  for(const p of hands[side]) s += (pieceValue[p]||0) * 0.95;
  for(const p of hands[opposite(side)]) s -= (pieceValue[p]||0) * 0.95;

  if(isKingInCheck(opposite(side))) s += 4.0;
  if(isKingInCheck(side)) s -= 12.0;

  s += kingSafetyScore(side) * 0.75;
  s -= kingSafetyScore(opposite(side)) * 0.25;

  return s;
}

/* ========= 指し手生成 ========= */
function generatePseudoMoves(side){
  const moves = [];

  // 盤上の移動
  for(let y=0;y<9;y++){
    for(let x=0;x<9;x++){
      const p = board[y][x];
      if(!p) continue;
      if(ownerOf(p) !== side) continue;

      for(let ty=0;ty<9;ty++){
        for(let tx=0;tx<9;tx++){
          if(tx===x && ty===y) continue;
          const t = board[ty][tx];
          if(t && ownerOf(t)===side) continue;
          if(!canMove(p,x,y,tx,ty)) continue;

          const base = baseKey(p);
          const promotable = ["P","L","N","S","B","R"].includes(base) && !isPromoted(p) && !hasNoPromoteFlag(p);
          const canPromoteHere = promotable && canPromoteByFromTo(side, y, ty);
          const must = promotable && mustPromote(base, side, ty);

          if(canPromoteHere){
            if(must){
              moves.push({type:"move", from:{x,y}, to:{x:tx,y:ty}, promote:true});
            }else{
              moves.push({type:"move", from:{x,y}, to:{x:tx,y:ty}, promote:true});
              moves.push({type:"move", from:{x,y}, to:{x:tx,y:ty}, promote:false});
            }
          }else{
            moves.push({type:"move", from:{x,y}, to:{x:tx,y:ty}, promote:false});
          }
        }
      }
    }
  }

  // 持ち駒の打ち
  for(let i=0;i<hands[side].length;i++){
    const piece = hands[side][i];
    for(let y=0;y<9;y++){
      for(let x=0;x<9;x++){
        if(board[y][x]) continue;
        if(isDeadSquareOnDrop(piece, side, y)) continue;
        if(piece==="P" && hasUnpromotedPawnInFile(side, x)) continue;
        moves.push({type:"drop", piece, handIdx:i, to:{x,y}});
      }
    }
  }

  return moves;
}

function applyMove(m, side){
  const snapshot = {
    board: deepCopy(board),
    hands: deepCopy(hands),
    turn
  };

  if(m.type==="move"){
    const fx=m.from.x, fy=m.from.y;
    const tx=m.to.x, ty=m.to.y;
    const fromPiece = board[fy][fx];
    const target = board[ty][tx];

    if(target){
      const capBase = baseKey(target);
      hands[side].push(capBase);
    }

    let moved = fromPiece;
    if(m.promote){
      moved = "+" + stripMeta(fromPiece);
    }

    board[ty][tx] = moved;
    board[fy][fx] = null;

    m._movedTo = {x:tx,y:ty};
    m._movedPiece = moved;
    m._captured = target;

  }else{
    const tx=m.to.x, ty=m.to.y;
    const piece = hands[side][m.handIdx];
    hands[side].splice(m.handIdx,1);
    const placed = (side==="sente") ? piece.toLowerCase() : piece.toUpperCase();
    board[ty][tx] = placed;

    m._movedTo = {x:tx,y:ty};
    m._movedPiece = placed;
    m._captured = null;
  }

  turn = opposite(side);
  return snapshot;
}

function undoApply(snapshot){
  board = snapshot.board;
  hands = snapshot.hands;
  turn = snapshot.turn;
}

function isLegalAfter(m, side){
  const snap = applyMove(m, side);
  const illegal = isKingInCheck(side);
  undoApply(snap);
  return !illegal;
}

function generateLegalMoves(side){
  const pseudo = generatePseudoMoves(side);
  const legal = [];
  for(const m of pseudo){
    if(isLegalAfter(m, side)) legal.push(m);
  }
  return legal;
}

/* ===== Lv5用：捕獲優先順位 ===== */
const capturePriorityRank = {
  "+R": 100, "+B": 95, "R": 90, "B": 80, "G": 70, "S": 60,
  "+P": 55, "+L": 55, "+N": 55, "+S": 55,
  "L": 40, "N": 35, "P": 10
};
function captureRankOfPiece(p){
  if(!p) return 0;
  const dk = displayKey(p);
  return capturePriorityRank[dk] || 0;
}

function hangingPenaltyForMoveLv5(m, moverSide){
  const to = m._movedTo;
  const movedPiece = m._movedPiece;
  if(!to || !movedPiece) return 0;

  const enemy = opposite(moverSide);
  const atks = attackersToSquare(enemy, to.x, to.y);
  if(atks.length===0) return 0;

  const defs = defendersToSquare(moverSide, to.x, to.y);
  const myV = valueOfPiece(movedPiece);

  if(defs.length===0){
    return myV * 2.2;
  }

  let minAtkV = 999;
  for(const a of atks) minAtkV = Math.min(minAtkV, valueOfPiece(a.piece));
  const cheapAttack = (minAtkV <= myV * 0.6) ? 1.0 : 0.5;

  return myV * (0.55 + 0.25*cheapAttack);
}

function hangingPenaltyForMove(m, moverSide){
  const to = m._movedTo;
  const movedPiece = m._movedPiece;
  if(!to || !movedPiece) return 0;

  const enemy = opposite(moverSide);
  const atks = attackersToSquare(enemy, to.x, to.y);
  if(atks.length===0) return 0;

  const myV = valueOfPiece(movedPiece);
  let minAtkV = 999;
  for(const a of atks){
    minAtkV = Math.min(minAtkV, valueOfPiece(a.piece));
  }
  const ratio = Math.max(0.2, Math.min(1.0, minAtkV / (myV+0.01)));
  return myV * (0.65 + 0.35*ratio);
}

function captureTradeBonus(m){
  if(m.type!=="move" || !m._captured) return 0;
  const capV = valueOfPiece(m._captured);
  const myV  = valueOfPiece(m._movedPiece);
  return Math.max(0, capV - myV*0.15);
}

/* ====== 手並び ====== */
function moveOrderScore(m, side){
  let score = 0;
  const inCheckBefore = isKingInCheck(side);
  if(inCheckBefore) score += 25;

  const snap = applyMove(m, side);

  const givesCheck = isKingInCheck(opposite(side));
  if(givesCheck) score += 30;

  if(m.type==="move" && m._captured){
    score += 10 + valueOfPiece(m._captured)*2;
  }
  if(aiLevel===5 && m.type==="move" && m._captured){
    const r = captureRankOfPiece(m._captured);
    score += r * 1.2;
  }

  if(m.type==="move" && m.promote) score += 10;

  score += captureTradeBonus(m);

  if(aiLevel===5){
    score -= hangingPenaltyForMoveLv5(m, side) * 1.25;
  }else{
    score -= hangingPenaltyForMove(m, side) * 0.7;
  }

  const enemyMoves = generateLegalMoves(turn);
  if(enemyMoves.length===0){
    score += 9999;
  }else{
    score += Math.max(0, 8 - enemyMoves.length) * 1.2;
  }

  undoApply(snap);
  return score;
}

/* ===== Lv5：詰み探索 ===== */
function mateSearch(attacker, maxPlies, deadlineMs){
  if(deadlineMs && performance.now() > deadlineMs) return null;

  const defender = opposite(attacker);

  const defMoves = generateLegalMoves(defender);
  if(defMoves.length===0){
    if(isKingInCheck(defender)) return 0;
    return null;
  }
  if(maxPlies<=0) return null;

  const atkMoves = generateLegalMoves(attacker);
  atkMoves.sort((a,b)=>moveOrderScore(b, attacker)-moveOrderScore(a, attacker));

  for(const m of atkMoves){
    if(deadlineMs && performance.now() > deadlineMs) return null;

    const snap = applyMove(m, attacker);
    const givesCheck = isKingInCheck(defender);

    if(!givesCheck){
      undoApply(snap);
      continue;
    }

    const replies = generateLegalMoves(defender);
    if(replies.length===0){
      undoApply(snap);
      return 1;
    }

    let allLose = true;
    for(const r of replies){
      if(deadlineMs && performance.now() > deadlineMs){ undoApply(snap); return null; }

      const snap2 = applyMove(r, defender);
      const res = mateSearch(attacker, maxPlies-2, deadlineMs);
      undoApply(snap2);

      if(res===null){
        allLose = false;
        break;
      }
    }

    undoApply(snap);

    if(allLose){
      return 1;
    }
  }

  return null;
}

/* ===== 3) Quiescence ===== */
function generateTacticalMoves(side){
  const legal = generateLegalMoves(side);
  const t = [];
  for(const m of legal){
    const snap = applyMove(m, side);
    const gaveCheck = isKingInCheck(opposite(side));
    const captured = (m.type==="move" && !!m._captured);
    undoApply(snap);
    if(captured || gaveCheck) t.push(m);
  }
  t.sort((a,b)=>moveOrderScore(b, side)-moveOrderScore(a, side));
  return t;
}

function quiescence(rootSide, alpha, beta, deadlineMs, qDepth){
  if(deadlineMs && performance.now() > deadlineMs){
    return evaluate(rootSide);
  }

  let standPat = evaluate(rootSide);

  const maximizing = (turn===rootSide);
  if(maximizing){
    if(standPat >= beta) return standPat;
    if(standPat > alpha) alpha = standPat;
  }else{
    if(standPat <= alpha) return standPat;
    if(standPat < beta) beta = standPat;
  }

  if(qDepth<=0) return standPat;

  const mover = turn;
  const moves = generateTacticalMoves(mover);
  if(moves.length===0) return standPat;

  let best = maximizing ? -1e9 : 1e9;

  for(const m of moves){
    if(deadlineMs && performance.now() > deadlineMs) break;

    const snap = applyMove(m, mover);
    const score = quiescence(rootSide, alpha, beta, deadlineMs, qDepth-1);
    undoApply(snap);

    if(maximizing){
      if(score>best) best=score;
      if(best>alpha) alpha=best;
      if(beta<=alpha) break;
    }else{
      if(score<best) best=score;
      if(best<beta) beta=best;
      if(beta<=alpha) break;
    }
  }

  if(maximizing) return Math.max(standPat, best);
  return Math.min(standPat, best);
}

/* ===== minimax（Lv5連続王手拡張 + quiescence）===== */
function minimax(rootSide, depth, alpha, beta, deadlineMs, checkChain, qDepth){
  if(deadlineMs && performance.now() > deadlineMs){
    return evaluate(rootSide);
  }
  if(depth===0){
    if(qDepth && qDepth>0) return quiescence(rootSide, alpha, beta, deadlineMs, qDepth);
    return evaluate(rootSide);
  }

  const mover = turn;
  const moves = generateLegalMoves(mover);
  if(moves.length===0) return evaluate(rootSide);

  moves.sort((a,b)=> moveOrderScore(b, mover) - moveOrderScore(a, mover));

  const maximizing = (turn===rootSide);
  let best = maximizing ? -1e9 : 1e9;

  for(const m of moves){
    if(deadlineMs && performance.now() > deadlineMs) break;

    const snap = applyMove(m, mover);

    const givesCheck = isKingInCheck(opposite(mover));
    const nextChain = givesCheck ? (checkChain+1) : 0;

    let extra = 0;
    if(aiLevel===5 && givesCheck){
      extra = Math.min(2, nextChain);
    }

    const score = minimax(rootSide, depth-1+extra, alpha, beta, deadlineMs, nextChain, qDepth);
    undoApply(snap);

    if(maximizing){
      if(score>best) best=score;
      if(best>alpha) alpha=best;
      if(beta<=alpha) break;
    }else{
      if(score<best) best=score;
      if(best<beta) beta=best;
      if(beta<=alpha) break;
    }
  }

  return best;
}

function maybeAIMove(){
  if(!vsAI) return;
  if(gameOver) return;
  if(turn !== "gote") return;
  if(confirmAction || promotionPending) return;
  if(aiThinking) return;

  aiThinking = true;

  setTimeout(()=>{
    try{
      doAIMove();
    } finally {
      aiThinking = false;
    }
  }, 150);
}

function aiParamsByLevel(lv){
  if(lv<=1) return {depthMax:2, noise:1.1, timeLimit:0,   matePlies:0,  qDepth:0, useIter:false};
  if(lv===2) return {depthMax:3, noise:0.6, timeLimit:0,   matePlies:0,  qDepth:0, useIter:false};
  if(lv===3) return {depthMax:4, noise:0.15,timeLimit:0,   matePlies:0,  qDepth:0, useIter:false};
  if(lv===4) return {depthMax:6, noise:0.03,timeLimit:260, matePlies:0,  qDepth:3, useIter:true};
  return {depthMax:9, noise:0.0, timeLimit:1800, matePlies:10, qDepth:5, useIter:true};
}

/* ===== 反復深化用：指定深さで最善手 ===== */
function searchBestMoveAtDepth(rootSide, depth, deadlineMs, qDepth){
  const mover = turn;
  const moves = generateLegalMoves(mover);
  if(moves.length===0) return {move:null, score: evaluate(rootSide)};

  moves.sort((a,b)=> moveOrderScore(b, mover) - moveOrderScore(a, mover));

  const maximizing = (mover===rootSide);
  let bestMove = moves[0];
  let bestScore = maximizing ? -1e9 : 1e9;

  for(const m of moves){
    if(deadlineMs && performance.now() > deadlineMs) break;

    const snap = applyMove(m, mover);
    const score = minimax(rootSide, Math.max(0, depth-1), -1e9, 1e9, deadlineMs, 0, qDepth);
    undoApply(snap);

    if(maximizing){
      if(score > bestScore){ bestScore = score; bestMove = m; }
    }else{
      if(score < bestScore){ bestScore = score; bestMove = m; }
    }
  }
  return {move: bestMove, score: bestScore};
}

function doAIMove(){
  if(gameOver) return;
  if(turn!=="gote") return;

  // ★定跡ブック優先（UI/音声変更なし）
  const bookMove = pickBookMoveForSide("gote");
  if(bookMove){
    bestMoveApplyAndSpeak(bookMove);
    return;
  }

  const {depthMax, noise, timeLimit, matePlies, qDepth, useIter} = aiParamsByLevel(aiLevel);
  const deadlineMs = timeLimit ? (performance.now() + timeLimit) : null;

  let moves = generateLegalMoves("gote");
  if(moves.length===0){
    speak("コンピュータは指す手がありません。");
    return;
  }

  moves.sort((a,b)=> moveOrderScore(b, "gote") - moveOrderScore(a, "gote"));

  let candidates = moves;
  if(aiLevel<=2 && moves.length>160) candidates = moves.slice(0, aiLevel===1 ? 60 : 110);
  else if(aiLevel===3 && moves.length>260) candidates = moves.slice(0, 200);

  if(aiLevel===5){
    const captureMoves = candidates.filter(m => m.type==="move");
    const scoredCaps = [];
    for(const m of captureMoves){
      const snap = applyMove(m, "gote");
      const cap = m._captured;
      const givesCap = !!cap;
      let capRank = givesCap ? captureRankOfPiece(cap) : 0;
      const risk = hangingPenaltyForMoveLv5(m, "gote");
      undoApply(snap);
      if(givesCap) scoredCaps.push({m, capRank, risk});
    }
    if(scoredCaps.length>=2){
      scoredCaps.sort((a,b)=> (b.capRank - a.capRank) || (a.risk - b.risk));
      const top = scoredCaps[0];
      if(top && top.risk < 25){
        candidates = [top.m, ...candidates.filter(x=>x!==top.m)];
      }
    }
  }

  if(aiLevel===5 && matePlies>0){
    for(const m of candidates){
      if(deadlineMs && performance.now() > deadlineMs) break;

      const snap = applyMove(m, "gote");
      const givesCheck = isKingInCheck("sente");

      let mateFound = false;
      if(givesCheck){
        const replies = generateLegalMoves("sente");
        if(replies.length===0 && isKingInCheck("sente")){
          mateFound = true;
        }else{
          const res = mateSearch("gote", matePlies, deadlineMs);
          if(res!==null) mateFound = true;
        }
      }

      undoApply(snap);

      if(mateFound){
        bestMoveApplyAndSpeak(m);
        return;
      }
    }
  }

  let bestMove = candidates[0];
  let bestScore = -1e9;

  if(useIter && deadlineMs){
    let lastGood = null;
    for(let d=1; d<=depthMax; d++){
      if(performance.now() > deadlineMs) break;
      const res = searchBestMoveAtDepth("gote", d, deadlineMs, qDepth);
      if(performance.now() > deadlineMs) break;
      if(res && res.move) lastGood = res;
    }
    if(lastGood && lastGood.move){
      bestMove = lastGood.move;
      bestScore = lastGood.score;
    }else{
      const res = searchBestMoveAtDepth("gote", 1, deadlineMs, qDepth);
      if(res && res.move){
        bestMove = res.move;
        bestScore = res.score;
      }
    }
  }else{
    bestMove = candidates[0];
    bestScore = -1e9;

    for(const m of candidates){
      if(deadlineMs && performance.now() > deadlineMs) break;

      const snap = applyMove(m, "gote");
      const score = minimax("gote", Math.max(1, depthMax-1), -1e9, 1e9, deadlineMs, 0, qDepth);
      undoApply(snap);

      const noisy = score + (Math.random()*2-1)*noise;
      if(noisy > bestScore){
        bestScore = noisy;
        bestMove = m;
      }
    }
  }

  bestMoveApplyAndSpeak(bestMove);
}

/* ========= 実際に反映（CPUはUI確認なしで直接 / 音声文言は変更しない） ========= */
function bestMoveApplyAndSpeak(bestMove){
  if(bestMove.type==="move"){
    const fx=bestMove.from.x, fy=bestMove.from.y;
    const tx=bestMove.to.x, ty=bestMove.to.y;

    const fromPiece = board[fy][fx];
    const target = board[ty][tx];

    if(target){
      const baseCaptured = baseKey(target);
      hands.gote.push(baseCaptured);
      if(baseCaptured==="K"){
        winner="後手";
        gameOver=true;
        lastMove={ player:"gote", text:"王を取りました。" };
        render();
        speak("つみです。後手の勝ちです。");
        return;
      }
    }

    let moved = fromPiece;
    if(bestMove.promote){
      moved = "+" + stripMeta(fromPiece);
    }

    board[ty][tx]=moved;
    board[fy][fx]=null;

    turn="sente";

    const pieceName = readMap[baseKey(fromPiece)];
    let say = `${coordText(tx,ty)}に${pieceName}を指しました。`;
    if(target) say += `${readMap[displayKey(target)]}を取りました。`;
    if(bestMove.promote) say += `${pieceName}が${readMap[displayKey(moved)]}になりました。`;
    if(isKingInCheck("sente")) say += "王手です。";
    say += "次はせんてのばんです。";

    lastMove={ player:"gote", text: say.replace("次はせんてのばんです。","") };
    render();
    speak(say);

  }else{
    const x=bestMove.to.x, y=bestMove.to.y;
    const idx=bestMove.handIdx;
    const piece = hands.gote[idx];
    if(!piece) return;

    board[y][x] = piece.toUpperCase();
    hands.gote.splice(idx,1);

    turn="sente";

    let say = `${coordText(x,y)}に${readMap[piece]}を打ちました。`;
    if(isKingInCheck("sente")) say += "王手です。";
    say += "次はせんてのばんです。";

    lastMove={ player:"gote", text: say.replace("次はせんてのばんです。","") };
    render();
    speak(say);
  }
}

/* ========= 起動 ========= */
initNums();
resetGame();
setAILevel(2);
// UI/音声には影響しない（失敗しても喋らない）
loadBookJson("./book.json");

// ===== 内部(x,y) <-> USI 変換 =====
function xyToUSI(x,y){
  const file = 9 - x; // 1..9
  const rank = String.fromCharCode(97 + y); // a..i
  return `${file}${rank}`;
}
function moveToUSIToken(m){
  if(m.type==="move"){
    const a = xyToUSI(m.from.x, m.from.y);
    const b = xyToUSI(m.to.x, m.to.y);
    return a + b + (m.promote?"+":"");
  }else{
    return `${m.piece.toUpperCase()}*${xyToUSI(m.to.x, m.to.y)}`;
  }
}

// ===== 両者用：簡易ベストムーブ選択（合法手のみ）=====
function pickBestMove(side, depth=2, deadlineMs=null){
  const moves = generateLegalMoves(side);
  if(moves.length===0) return null;

  // ざっくり手並び（既存の moveOrderScore を活用）
  moves.sort((a,b)=> moveOrderScore(b, side) - moveOrderScore(a, side));

  let best = moves[0];
  let bestScore = -1e9;

  for(const m of moves){
    if(deadlineMs && performance.now() > deadlineMs) break;

    const snap = applyMove(m, side);
    // depth-1 だけ読む（あなたの minimax を流用）
    const sc = minimax(side, Math.max(1, depth-1), -1e9, 1e9, deadlineMs, 0);
    undoApply(snap);

    if(sc > bestScore){
      bestScore = sc;
      best = m;
    }
  }
  return best;
}

// ===== 角換わり“導入”の固定手順（合法チェックして適用）=====
// ※あなたの盤実装に合わない場合は途中で止まり、どの手で止まったかをconsoleに出します
function applyForcedKakugawariIntro(){
  const intro = [
    "7g7f", // ▲7六歩
    "3c3d", // △3四歩
    "8h2b+",// ▲角交換（成り）
    "3a2b", // △銀で角を取る
    "2g2f", // ▲2六歩
    "8c8d", // △8四歩
    "2f2e", // ▲2五歩
    "8d8e"  // △8五歩
  ];

  for(const tok of intro){
    const mv = parseUSIMove(tok); // あなたが前に入れたUSIパーサが必要
    if(!mv) throw new Error("USI parse failed: " + tok);
    applyMoveSilentlyChecked(mv); // 無音で合法チェック→適用（前に入れた関数）
  }
}


// ===== 角換わり“風”サンプル棋譜を自動生成（USI）=====
// plies = 100 なら「100手番」ぶん（先手50+後手50）
function generateKakugawariSampleUSI(plies=100, depth=2, timeLimitMs=1200){
  // 無音初期化（あなたが追加済みの silentResetToStart が必要）
  silentResetToStart();

  // 角換わり導入を強制
  try{
    applyForcedKakugawariIntro();
  }catch(e){
    console.error("❌ 角換わり導入で失敗:", e);
    console.error("→ このエラー文をそのまま私に貼ってください。導入手順をあなたのルールに合わせて調整します。");
    return "";
  }

  // ここまでのUSIログを作る
  let tokens = [
    "7g7f","3c3d","8h2b+","3a2b","2g2f","8c8d","2f2e","8d8e"
  ];

  const deadlineMs = timeLimitMs ? (performance.now() + timeLimitMs) : null;

  // すでに8ply入っているので、残りを生成
  while(tokens.length < plies){
    const side = turn; // 現在手番
    const mv = pickBestMove(side, depth, deadlineMs);
    if(!mv) break;

    // 変換用に、dropのpieceを持たせる（applyMoveの後だと手駒idxが変わるので先に）
    let tokenForThis;
    if(mv.type==="drop"){
      // mvは {type:"drop", piece, handIdx, to} になっているので piece はある
      tokenForThis = moveToUSIToken({type:"drop", piece: mv.piece, to: mv.to});
    }else{
      tokenForThis = moveToUSIToken({type:"move", from: mv.from, to: mv.to, promote: !!mv.promote});
    }

    // 実際に適用（合法手のみなのでそのままapplyMoveでOK）
    applyMove(mv, side);

    tokens.push(tokenForThis);

    if(deadlineMs && performance.now() > deadlineMs) break;
  }

  return tokens.join(" ");
}

// ===== USI文字列を1手に変換 =====
function usiToXY(fileChar, rankChar){
  const file = parseInt(fileChar, 10);
  const rank = rankChar.charCodeAt(0) - 97;
  return { x: 9 - file, y: rank };
}

function parseUSIMove(token){
  token = token.trim();
  if(!token) return null;

  // 打ち駒例：P*7f
  if(token.includes("*")){
    const piece = token[0].toUpperCase();
    const to = usiToXY(token[2], token[3]);
    return { type:"drop", piece, to };
  }

  // 通常移動例：7g7f または 2b3c+
  const from = usiToXY(token[0], token[1]);
  const to   = usiToXY(token[2], token[3]);
  const promote = token.endsWith("+");

  return { type:"move", from, to, promote };
}

// ===== 無音で合法チェックして盤に適用 =====
function applyMoveSilentlyChecked(mv){
  const side = turn;

  // 移動
  if(mv.type==="move"){
    const fx=mv.from.x, fy=mv.from.y;
    const tx=mv.to.x, ty=mv.to.y;

    const piece = board[fy][fx];
    if(!piece) throw new Error("fromに駒がありません");

    if(ownerOf(piece)!==side) throw new Error("手番と一致しません");

    const moveObj = {
      type:"move",
      from:{x:fx,y:fy},
      to:{x:tx,y:ty},
      promote:!!mv.promote
    };

    if(!isLegalAfter(moveObj, side)){
      throw new Error("非合法手です");
    }

    applyMove(moveObj, side);
    return;
  }

  // 打ち
  if(mv.type==="drop"){
    const idx = hands[side].indexOf(mv.piece);
    if(idx<0) throw new Error("持ち駒がありません");

    const dropObj = {
      type:"drop",
      piece: mv.piece,
      handIdx: idx,
      to: mv.to
    };

    if(!isLegalAfter(dropObj, side)){
      throw new Error("非合法な打ちです");
    }

    applyMove(dropObj, side);
    return;
  }
}

// ===== 無音で初期局面に戻す =====
function silentResetToStart(){
  board=[
    ["L","N","S","G","K","G","S","N","L"],
    [null,"R",null,null,null,null,null,"B",null],
    ["P","P","P","P","P","P","P","P","P"],
    [null,null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null,null],
    [null,null,null,null,null,null,null,null,null],
    ["p","p","p","p","p","p","p","p","p"],
    [null,"b",null,null,null,null,null,"r",null],
    ["l","n","s","g","k","g","s","n","l"]
  ];
  hands={sente:[], gote:[]};
  turn="sente";
}

function addBookMove(posKey, moveObj, w=1){
  if(!OPENING_BOOK) OPENING_BOOK = {};
  if(!OPENING_BOOK[posKey]) OPENING_BOOK[posKey]=[];
  const list = OPENING_BOOK[posKey];
  const s = JSON.stringify(moveObj);
  const found = list.find(e => JSON.stringify(e.m)===s);
  if(found) found.w += w;
  else list.push({m: moveObj, w});
}

function buildBookFromUSI(usiText, maxPlies=200){
  OPENING_BOOK = {};
  silentResetToStart();

  const tokens = usiText
    .replace(/\r/g," ")
    .replace(/\n/g," ")
    .split(/\s+/)
    .filter(Boolean);

  let ply=0;
  for(const t of tokens){
    if(ply>=maxPlies) break;

    const mv = parseUSIMove(t);
    if(!mv) continue;

    const key = positionKey();

    let bookMv;
    if(mv.type==="move"){
      bookMv = {type:"move", from:mv.from, to:mv.to, promote:!!mv.promote};
    }else{
      bookMv = {type:"drop", piece:mv.piece, to:mv.to};
    }

    addBookMove(key, bookMv, 1);

    // 無音で合法チェックして適用
    applyMoveSilentlyChecked(mv);

    ply++;
  }

  return OPENING_BOOK;
}

function generateBookJsonFromUSIToConsole(usiText, maxPlies=200){
  const book = buildBookFromUSI(usiText, maxPlies);
  console.log(JSON.stringify(book));
  console.log("✅ 上のJSONを book.json として保存し、index.html と同じフォルダへ置いてください。");
}

// ===== bookを追記できるようにする（上書きじゃなく追加）=====
function appendBookFromUSI(usiText, maxPlies=200, weight=1){
  // OPENING_BOOKが無ければ作る
  if(!OPENING_BOOK) OPENING_BOOK = {};
  // 局面を初期化して流す
  silentResetToStart();

  const tokens = usiText
    .replace(/\r/g," ")
    .replace(/\n/g," ")
    .split(/\s+/)
    .filter(Boolean);

  let ply=0;
  for(const t of tokens){
    if(ply>=maxPlies) break;

    const mv = parseUSIMove(t);
    if(!mv) continue;

    const key = positionKey();

    let bookMv;
    if(mv.type==="move"){
      bookMv = {type:"move", from:mv.from, to:mv.to, promote:!!mv.promote};
    }else{
      bookMv = {type:"drop", piece:mv.piece, to:mv.to};
    }

    addBookMove(key, bookMv, weight);

    applyMoveSilentlyChecked(mv);
    ply++;
  }
}

// ===== 角換わり導入 + 分岐つき自動生成 =====
function generateBranchingUSI(plies=60, depth=2, timeLimitMs=800, randomness=0.35){
  // 初期化
  silentResetToStart();

  // 角換わり導入（あなたが今使っている導入）
  applyForcedKakugawariIntro();

  // ここまでのUSI（導入分）を tokens にする
  // ※導入を変えたらここも合わせてください
  let tokens = ["7g7f","3c3d","2g2f","8c8d","2f2e","8d8e"];

  const deadlineMs = timeLimitMs ? (performance.now() + timeLimitMs) : null;

  while(tokens.length < plies){
    const side = turn;
    const moves = generateLegalMoves(side);
    if(moves.length===0) break;

    // 手並び
    moves.sort((a,b)=> moveOrderScore(b, side) - moveOrderScore(a, side));

    // ランダム分岐：上位候補から確率的に選ぶ（同じ形ばかりを防ぐ）
    const topN = Math.max(2, Math.min(10, Math.floor(moves.length * 0.12)));
    const pool = moves.slice(0, topN);

    let chosen = pool[0];

    if(Math.random() < randomness){
      // 上位からランダム選択（上ほど出やすい）
      // 例：0が一番出やすい分布
      const r = Math.random();
      const idx = Math.floor((r*r) * pool.length);
      chosen = pool[idx];
    }else{
      // たまに深読みで本命を選ぶ
      chosen = pickBestMove(side, depth, deadlineMs) || pool[0];
    }

    // USI化
    let tok;
    if(chosen.type==="drop"){
      tok = moveToUSIToken({type:"drop", piece: chosen.piece, to: chosen.to});
    }else{
      tok = moveToUSIToken({type:"move", from: chosen.from, to: chosen.to, promote: !!chosen.promote});
    }

    applyMove(chosen, side);
    tokens.push(tok);

    if(deadlineMs && performance.now() > deadlineMs) break;
  }

  return tokens.join(" ");
}

// ===== まとめて大量生成して book.json をConsoleに出す =====
function generateBigBookJsonToConsole(lines=60, plies=60){
  OPENING_BOOK = {}; // いったん全消しして作り直す

  for(let i=0;i<lines;i++){
    const usi = generateBranchingUSI(plies, 2, 700, 0.45);
    // 本命っぽい線ほど重みを高く（最初の方は重み高め）
    const w = (i<10)? 5 : (i<30)? 3 : 1;
    appendBookFromUSI(usi, plies, w);
  }

  console.log(JSON.stringify(OPENING_BOOK));
  console.log(`✅ 生成OK：lines=${lines}, plies=${plies}。上のJSONを book.json として保存してください。`);
}

// ===== moveをbook登録用に正規化 =====
function normalizeForBook(m){
  if(m.type==="move"){
    return {type:"move", from:{x:m.from.x,y:m.from.y}, to:{x:m.to.x,y:m.to.y}, promote:!!m.promote};
  }
  // dropは piece を必ず入れる（handIdxは入れない）
  return {type:"drop", piece: m.piece, to:{x:m.to.x,y:m.to.y}};
}

// ===== 角換わり導入（内部moveで安全に）=====
// ※いまはあなたの導入が「歩進め」だけなので、それをそのまま内部moveで適用
function applyForcedIntroInternal(){
  const introUSI = ["7g7f","3c3d","2g2f","8c8d","2f2e","8d8e"];
  for(const tok of introUSI){
    const mv = parseUSIMove(tok);
    applyMoveSilentlyChecked(mv);
  }
}

// ===== 上位候補から分岐しながら1局面ずつbookへ追加（USI不要）=====
function generateAndRecordOneLine(plies=60, depth=2, randomness=0.45, timeLimitMs=700){
  silentResetToStart();
  applyForcedIntroInternal();

  const deadlineMs = timeLimitMs ? (performance.now() + timeLimitMs) : null;

  let ply = 0;
  while(ply < plies){
    const side = turn;

    const moves = generateLegalMoves(side);
    if(moves.length===0) break;

    moves.sort((a,b)=> moveOrderScore(b, side) - moveOrderScore(a, side));
    const topN = Math.max(2, Math.min(10, Math.floor(moves.length * 0.12)));
    const pool = moves.slice(0, topN);

    let chosen = pool[0];

    if(Math.random() < randomness){
      const r = Math.random();
      const idx = Math.floor((r*r) * pool.length);
      chosen = pool[idx];
    }else{
      chosen = pickBestMove(side, depth, deadlineMs) || pool[0];
    }

    // いまの局面に、この手をbookとして登録
    const key = positionKey();
    addBookMove(key, normalizeForBook(chosen), 1);

    // 実際に進める（内部moveなので持ち駒矛盾が起きない）
    applyMove(chosen, side);

    ply++;
    if(deadlineMs && performance.now() > deadlineMs) break;
  }
}

// ===== 大量生成：直接OPENING_BOOKを作ってJSON出力 =====
function generateBigBookJsonToConsole_V2(lines=80, plies=60){
  OPENING_BOOK = {};

  for(let i=0;i<lines;i++){
    // 最初の方のラインは重みを強めにする（本命感）
    const w = (i<10)? 5 : (i<30)? 3 : 1;

    // 1ライン生成して登録（同一局面に何度も登録される＝分岐が増える）
    silentResetToStart();
    applyForcedIntroInternal();

    const deadlineMs = performance.now() + 700;

    let ply=0;
    while(ply < plies){
      const side = turn;
      const moves = generateLegalMoves(side);
      if(moves.length===0) break;

      moves.sort((a,b)=> moveOrderScore(b, side) - moveOrderScore(a, side));
      const topN = Math.max(2, Math.min(10, Math.floor(moves.length * 0.12)));
      const pool = moves.slice(0, topN);

      let chosen = pool[0];
      if(Math.random() < 0.45){
        const r = Math.random();
        chosen = pool[Math.floor((r*r)*pool.length)];
      }else{
        chosen = pickBestMove(side, 2, deadlineMs) || pool[0];
      }

      const key = positionKey();
      if(shouldRecordForBook(chosen, side)){
        addBookMove(key, normalizeForBook(chosen), w);
      }

      applyMove(chosen, side);
      ply++;

      if(performance.now() > deadlineMs) break;
    }
  }

  console.log(JSON.stringify(OPENING_BOOK));
  console.log(`✅ V2生成OK：lines=${lines}, plies=${plies}。上のJSONを book.json として保存してください。`);
}

function shouldRecordForBook(m, side){
  const snap = applyMove(m, side);
  const gaveCheck = isKingInCheck(opposite(side));
  const captured = (m.type==="move" && !!m._captured);
  const promoted = (m.type==="move" && !!m.promote);
  const sc = evaluate(side);
  undoApply(snap);

  // どれか当てはまる時だけbookに入れる
  return gaveCheck || captured || promoted || sc > 1.0;
}

</script>
</body>
</html>






